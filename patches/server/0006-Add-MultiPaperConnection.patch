From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Mon, 15 Nov 2021 13:01:36 +1000
Subject: [PATCH] Add MultiPaperConnection


diff --git a/build.gradle.kts b/build.gradle.kts
index 92dc8b57f2f2bbbe0ffbcd098d7e1e31745f3d8d..8271eb803110f7e1ede19027e3d9b185df826223 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -13,6 +13,7 @@ configurations.named(log4jPlugins.compileClasspathConfigurationName) {
 val alsoShade: Configuration by configurations.creating
 
 dependencies {
+    implementation(project(":multipaper-mastermessagingprotocol")) // MultiPaper
     // Purpur start
     implementation(project(":multipaper-api")) // MultiPaper // Purpur
     implementation("io.papermc.paper:paper-mojangapi:${project.version}") {
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 8edff3d57726025480b86e5f948161c276de4c9a..d615366995282561c59e758970007a8bf6ee35fb 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -70,6 +70,7 @@ import org.bukkit.configuration.file.YamlConfiguration;
 
 import puregero.multipaper.config.MultiPaperConfiguration;
 import puregero.multipaper.config.MultiPaperConfigurationLoader;
+import puregero.multipaper.MultiPaper;
 
 public class Main {
 
@@ -122,6 +123,7 @@ public class Main {
 
             MultiPaperConfigurationLoader.init((File) optionset.valueOf("multipaper-settings")); // MultiPaper
             System.setProperty("multipaper.master-connection.my-name", MultiPaperConfiguration.get().masterConnection.myName); // MultiPaper - remember this property even after config reloads
+            MultiPaper.getConnection(); // MultiPaper - start connection
 
             io.papermc.paper.plugin.PluginInitializerManager.load(optionset); // Paper
             Bootstrap.bootStrap();
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 60b5e0643d933393b5473681ac9261db29fe2416..e48caf562f64cf520ae15abf116fc0f54579221b 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -190,6 +190,7 @@ import org.bukkit.event.server.ServerLoadEvent;
 // CraftBukkit end
 
 import co.aikar.timings.MinecraftTimings; // Paper
+import puregero.multipaper.MultiPaper;
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, CommandSource, AutoCloseable {
 
diff --git a/src/main/java/puregero/multipaper/ExternalServer.java b/src/main/java/puregero/multipaper/ExternalServer.java
new file mode 100644
index 0000000000000000000000000000000000000000..11bdc8c0cbbf8816c17de20d19dbc7e3df2f8472
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ExternalServer.java
@@ -0,0 +1,40 @@
+package puregero.multipaper;
+
+public class ExternalServer {
+    private final String name;
+    private final boolean me;
+    private int averageTickTime;
+    private double tps;
+    private long lastAlive;
+    public ExternalServer(String name, boolean me) {
+        this.name = name;
+        this.me = me;
+    }
+    public int getAverageTickTime() {
+        return averageTickTime;
+    }
+    public void setAverageTickTime(int averageTickTime) {
+        this.averageTickTime = averageTickTime;
+    }
+    public long getLastAlive() {
+        return lastAlive;
+    }
+    public void setLastAlive(long lastAlive) {
+        this.lastAlive = lastAlive;
+    }
+    public String getName() {
+        return name;
+    }
+    public boolean isMe() {
+        return me;
+    }
+    public boolean isAlive() {
+        return getLastAlive() > System.currentTimeMillis() - 2500 && getTps() > 0;
+    }
+    public double getTps() {
+        return tps;
+    }
+    public void setTps(double tps) {
+        this.tps = tps;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
new file mode 100644
index 0000000000000000000000000000000000000000..435e6bfe575f88446d1f4657d4894991dd136971
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -0,0 +1,11 @@
+package puregero.multipaper;
+
+public class MultiPaper {
+    private static MultiPaperConnection multiPaperConnection = null;
+    public static MultiPaperConnection getConnection() {
+        if (multiPaperConnection == null) {
+            multiPaperConnection = new MultiPaperConnection();
+        }
+        return multiPaperConnection;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
new file mode 100644
index 0000000000000000000000000000000000000000..ad5cc195126c6bc939fbe5785529fdb7d427d8c5
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -0,0 +1,103 @@
+package puregero.multipaper;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.socket.SocketChannel;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.config.MultiPaperConfiguration;
+import puregero.multipaper.mastermessagingprotocol.MessageBootstrap;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.HelloMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.MasterBoundMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.MasterBoundProtocol;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.ServerBoundMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.ServerBoundMessageHandler;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.ServerBoundProtocol;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.ServerInfoUpdateMessage;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
+@ChannelHandler.Sharable
+public class MultiPaperConnection extends ServerBoundMessageHandler {
+    private static final Logger LOGGER = LogManager.getLogger(MultiPaperConnection.class.getSimpleName());
+    private static final UUID thisServersUuid = UUID.randomUUID();
+    private final String myName;
+    private final MessageBootstrap<ServerBoundMessage, MasterBoundMessage> bootstrap;
+    private SocketChannel channel;
+    private boolean channelActive = false;
+    private final Set<MasterBoundMessage> unhandledRequests = ConcurrentHashMap.newKeySet();
+    private final Map<String, ExternalServer> serversMap = new ConcurrentHashMap<>();
+    public MultiPaperConnection() {
+        System.setProperty("multipaper.netty.threads", System.getProperty("multipaper.netty.threads", Integer.toString(Math.min(Runtime.getRuntime().availableProcessors(), 3))));
+        myName = MultiPaperConfiguration.get().masterConnection.myName;
+        bootstrap = new MessageBootstrap<>(new ServerBoundProtocol(), new MasterBoundProtocol(), channel -> channel.pipeline().addLast(this));
+        connect();
+    }
+    public void connect() {
+        String server = MultiPaperConfiguration.get().masterConnection.masterAddress;
+        LOGGER.info("Connecting to " + server + "...");
+        String[] serverParts = server.split(":");
+        bootstrap.connectTo(serverParts[0], Integer.parseInt(serverParts[1])).addListener(future -> {
+            if (future.cause() != null) {
+                CompletableFuture.delayedExecutor(1, TimeUnit.SECONDS).execute(this::connect);
+            }
+        });
+    }
+    public Channel getChannel() {
+        return channel;
+    }
+    @Override
+    public void channelActive(ChannelHandlerContext ctx) {
+        channel = (SocketChannel) ctx.channel();
+        LOGGER.info("Connected to " + channel.remoteAddress());
+        channel.write(new HelloMessage(myName, thisServersUuid));
+        for (MasterBoundMessage unhandledRequest : unhandledRequests) {
+            channel.write(unhandledRequest);
+        }
+        channelActive = true;
+        channel.flush();
+    }
+    @Override
+    public void channelInactive(ChannelHandlerContext ctx) {
+        channelActive = false;
+        LOGGER.info("Lost connection to " + ((SocketChannel) ctx.channel()).remoteAddress());
+        connect();
+    }
+    private void waitForActiveChannel() {
+        while (channel == null || !channel.isActive() || !channelActive) {
+            // Wait for channel to become active
+            try {
+                Thread.sleep(50);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+    public void send(MasterBoundMessage message) {
+        waitForActiveChannel();
+        channel.writeAndFlush(message);
+    }
+    public void send(MasterBoundMessage message, Consumer<ServerBoundMessage> callback) {
+        waitForActiveChannel();
+        unhandledRequests.add(message);
+        send(setCallback(message, reply -> {
+            unhandledRequests.remove(message);
+            callback.accept(reply);
+        }));
+    }
+    public Map<String, ExternalServer> getServersMap() {
+        return serversMap;
+    }
+    @Override
+    public void handle(ServerInfoUpdateMessage message) {
+        ExternalServer server = serversMap.computeIfAbsent(message.name, key -> new ExternalServer(key, key.equals(myName)));
+        server.setAverageTickTime(message.averageTickTime);
+        server.setTps(message.tps);
+        server.setLastAlive(System.currentTimeMillis());
+    }
+}
\ No newline at end of file
