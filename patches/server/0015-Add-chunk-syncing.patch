From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Tue, 16 Nov 2021 19:23:16 +1000
Subject: [PATCH] Add chunk syncing


diff --git a/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Object.java b/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Object.java
index 7bab31a312463cc963d9621cdc543a281459bd32..7d49a0bdb11afd8616a97d6c7f043f9d2b0ce073 100644
--- a/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Object.java
+++ b/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Object.java
@@ -42,6 +42,12 @@ public class QueuedChangesMapLong2Object<V> {
         return this.updatingMap.remove(k);
     }
 
+    // MultiPaper start
+    public boolean isQueuedToRemove(final long k) {
+        return this.queuedChanges.get(k) == REMOVED;
+    }
+    // MultiPaper end
+
     public V getUpdating(final long k) {
         return this.updatingMap.get(k);
     }
diff --git a/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java b/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
index 2934f0cf0ef09c84739312b00186c2ef0019a165..95f32d117c6431ef01125a4a283e262d354f6741 100644
--- a/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
+++ b/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
@@ -814,6 +814,7 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
 
     private static Boolean doesRegionFileExist(final int chunkX, final int chunkZ, final boolean intendingToBlock,
                                                final ChunkDataController taskController) {
+        if (true) return Boolean.TRUE; // MultiPaper - always return true
         final ChunkPos chunkPos = new ChunkPos(chunkX, chunkZ);
         if (intendingToBlock) {
             return taskController.computeForRegionFile(chunkX, chunkZ, true, (final RegionFile file) -> {
diff --git a/src/main/java/io/papermc/paper/chunk/system/light/LightQueue.java b/src/main/java/io/papermc/paper/chunk/system/light/LightQueue.java
index de28d6ee71990da74d9deb360fac8bde5adbc918..c5592e5be9fe3c13e8729f31110ad4d2bd3ccb6f 100644
--- a/src/main/java/io/papermc/paper/chunk/system/light/LightQueue.java
+++ b/src/main/java/io/papermc/paper/chunk/system/light/LightQueue.java
@@ -22,7 +22,7 @@ import java.util.function.BooleanSupplier;
 
 public final class LightQueue {
 
-    protected final Long2ObjectOpenHashMap<ChunkTasks> chunkTasks = new Long2ObjectOpenHashMap<>();
+    public final Long2ObjectOpenHashMap<ChunkTasks> chunkTasks = new Long2ObjectOpenHashMap<>(); // MultiPaper - make public
     protected final StarLightInterface manager;
     protected final ServerLevel world;
 
@@ -31,6 +31,18 @@ public final class LightQueue {
         this.world = ((ServerLevel)manager.getWorld());
     }
 
+    // MultiPaper start - get Chunk on lighting complete
+    public CompletableFuture<Void> getChunkFuture(final ChunkPos chunkPos) {
+        ChunkTasks tasks = chunkTasks.get(chunkPos.longKey);
+
+        if (tasks == null) {
+            return CompletableFuture.completedFuture(null);
+        }
+
+        return tasks.onComplete;
+    }
+    // MultiPaper end - get Chunk on lighting complete
+
     public void lowerPriority(final int chunkX, final int chunkZ, final PrioritisedExecutor.Priority priority) {
         final ChunkTasks task;
         synchronized (this) {
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
index e1ffd62f4ebceecb9bc5471df3da406cffea0483..e4f697681721b83172a26852ee30ec3e10dcd68a 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
@@ -1041,7 +1041,7 @@ public final class ChunkHolderManager {
         }
     }
 
-    private void removeChunkHolder(final NewChunkHolder holder) {
+    public void removeChunkHolder(final NewChunkHolder holder) { // MultiPaper - make public (unsafe method, do not use!!!)
         holder.killed = true;
         holder.vanillaChunkHolder.onChunkRemove();
         this.autoSaveQueue.remove(holder);
@@ -1301,6 +1301,65 @@ public final class ChunkHolderManager {
         }
     }
 
+    // MultiPaper start
+    public void unloadChunkNowNoSave(NewChunkHolder chunkHolder) {
+        TickThread.ensureTickThread("Cannot unload chunks off-main");
+
+        if (BLOCK_TICKET_UPDATES.get() == Boolean.TRUE) {
+            throw new IllegalStateException("Cannot unload chunks recursively");
+        }
+        if (this.ticketLockArea.isHeldByCurrentThread(chunkHolder.chunkX, chunkHolder.chunkZ)) {
+            throw new IllegalStateException("Cannot hold ticket update lock while calling processUnloads");
+        }
+        if (this.taskScheduler.schedulingLockArea.isHeldByCurrentThread(chunkHolder.chunkX, chunkHolder.chunkZ)) {
+            throw new IllegalStateException("Cannot hold scheduling lock while calling processUnloads");
+        }
+
+        NewChunkHolder.UnloadState state;
+
+        final ReentrantAreaLock.Node ticketLock = this.ticketLockArea.lock(chunkHolder.chunkX, chunkHolder.chunkZ);
+        try {
+            final ReentrantAreaLock.Node schedulingLock = this.taskScheduler.schedulingLockArea.lock(chunkHolder.chunkX, chunkHolder.chunkZ);
+            try {
+                state = chunkHolder.unloadStage1();
+                if (state == null) {
+                    // can unload immediately
+                    this.removeChunkHolder(chunkHolder);
+                    return;
+                }
+            } finally {
+                this.taskScheduler.schedulingLockArea.unlock(schedulingLock);
+            }
+        } finally {
+            this.ticketLockArea.unlock(ticketLock);
+        }
+
+        final Boolean before = this.blockTicketUpdates();
+        try {
+            chunkHolder.unloadStage2(state, true);
+        } finally {
+            this.unblockTicketUpdates(before);
+        }
+
+        final ReentrantAreaLock.Node ticketLock2 = this.ticketLockArea.lock(chunkHolder.chunkX, chunkHolder.chunkZ);
+        try {
+            final ReentrantAreaLock.Node schedulingLock2 = this.taskScheduler.schedulingLockArea.lock(chunkHolder.chunkX, chunkHolder.chunkZ);
+            try {
+                if (chunkHolder.unloadStage3()) {
+                    this.removeChunkHolder(chunkHolder);
+                } else {
+                    // add cooldown so the next unload check is not immediately next tick
+                    this.addTicketAtLevel(TicketType.UNLOAD_COOLDOWN, chunkHolder.chunkX, chunkHolder.chunkZ, MAX_TICKET_LEVEL, Unit.INSTANCE);
+                }
+            } finally {
+                this.taskScheduler.schedulingLockArea.unlock(schedulingLock2);
+            }
+        } finally {
+            this.ticketLockArea.unlock(ticketLock2);
+        }
+    }
+    // MultiPaper end
+
     private final ThreadLocal<Boolean> BLOCK_TICKET_UPDATES = ThreadLocal.withInitial(() -> {
         return Boolean.FALSE;
     });
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
index e6f56bc5b129699bab60db9c97c7f73b6ede2351..1b2f876bbfcfe17767ad64e9b5fbfcccd2d101fe 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
@@ -36,12 +36,21 @@ import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.storage.ChunkSerializer;
 import net.minecraft.world.level.chunk.storage.EntityStorage;
 import org.slf4j.Logger;
+import puregero.multipaper.ExternalServer;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.SubscribeChunkMessage;
+
+import javax.annotation.Nullable;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
@@ -64,6 +73,10 @@ public final class NewChunkHolder {
 
     public final ChunkTaskScheduler scheduler;
 
+    @Nullable public ExternalServer externalOwner; // MultiPaper - Chunk owner
+    public Set<ExternalServer> externalSubscribers = ConcurrentHashMap.newKeySet(); // MultiPaper - Chunk subscribers
+    public boolean hasExternalLockRequest = false; // MultiPaper - Have we sent a request to lock this chunk?
+
     // load/unload state
 
     // chunk data state
@@ -445,6 +458,24 @@ public final class NewChunkHolder {
 
     private ChunkAccess currentChunk;
 
+    // MultiPaper start - listen for loading of the current chunk
+    private CompletableFuture<ChunkAccess> onCurrentChunkLoaded;
+    public CompletableFuture<ChunkAccess> onCurrentChunkLoaded() {
+        if (!this.hasGenerationTask()) {
+            if (onCurrentChunkLoaded == null || (onCurrentChunkLoaded.isDone() && onCurrentChunkLoaded.getNow(null) != currentChunk)) {
+                onCurrentChunkLoaded = CompletableFuture.completedFuture(currentChunk);
+            }
+            return onCurrentChunkLoaded;
+        }
+
+        if (onCurrentChunkLoaded == null || onCurrentChunkLoaded.isDone()) {
+            onCurrentChunkLoaded = new CompletableFuture<>();
+        }
+
+        return onCurrentChunkLoaded;
+    }
+    // MultiPaper end
+
     // generation status state
 
     /**
@@ -815,13 +846,14 @@ public final class NewChunkHolder {
         }
     }
 
-    void unloadStage2(final UnloadState state) {
+    void unloadStage2(final UnloadState state) { unloadStage2(state, false); } // MultiPaper - add option to not save chunk
+    void unloadStage2(final UnloadState state, boolean doNotSaveChunk) { // MultiPaper - add option to not save chunk
         this.unloadState = null;
         final ChunkAccess chunk = state.chunk();
         final ChunkEntitySlices entityChunk = state.entityChunk();
         final PoiChunk poiChunk = state.poiChunk();
 
-        final boolean shouldLevelChunkNotSave = (chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave);
+        final boolean shouldLevelChunkNotSave = doNotSaveChunk || (chunk instanceof LevelChunk levelChunk && levelChunk.mustNotSave); // MultiPaper - add option to not save chunk
 
         // unload chunk data
         if (chunk != null) {
@@ -838,10 +870,13 @@ public final class NewChunkHolder {
             if (chunk instanceof LevelChunk levelChunk) {
                 this.world.unload(levelChunk);
             }
+
+            MultiPaperChunkHandler.onChunkUnload(this, chunk, entityChunk); // MultiPaper
         }
 
         // unload entity data
         if (entityChunk != null) {
+            if (!doNotSaveChunk) // MultiPaper - add option to not save chunk
             this.saveEntities(entityChunk, true);
             // yes this is a hack to pass the compound tag through...
             final CompoundTag lastEntityUnload = this.lastEntityUnload;
@@ -1229,6 +1264,7 @@ public final class NewChunkHolder {
                 for (int dx = -NEIGHBOUR_RADIUS; dx <= NEIGHBOUR_RADIUS; ++dx) {
                     final NewChunkHolder holder = (dx | dz) == 0 ? this : this.scheduler.chunkHolderManager.getChunkHolder(dx + this.chunkX, dz + this.chunkZ);
                     if (loaded) {
+                        if (holder == null) LOGGER.warn("Holder for ({},{}) is null while updating full status for ({},{})", dx + this.chunkX, dz + this.chunkZ, this.chunkX, this.chunkZ); // MultiPaper
                         if (holder.setNeighbourFullLoaded(-dx, -dz)) {
                             changedFullStatus.add(holder);
                         }
@@ -1569,6 +1605,7 @@ public final class NewChunkHolder {
         this.currentChunk = newChunk;
         this.currentGenStatus = newStatus;
         this.lastChunkCompletion = new ChunkCompletion(newChunk, newStatus);
+        MultiPaper.getConnection().send(new SubscribeChunkMessage(world.getWorld().getName(), chunkX, chunkZ)); // MultiPaper - ensure we're subscribed to this chunk
 
         final ChunkStatus requestedGenStatus = this.requestedGenStatus;
 
@@ -1648,6 +1685,8 @@ public final class NewChunkHolder {
 
             this.scheduleNeighbours(needsScheduling, scheduleList);
         }
+
+        if (onCurrentChunkLoaded != null) onCurrentChunkLoaded.completeAsync(() -> currentChunk, world.getServer()::scheduleOnMain); // MultiPaper - listen for loading of the current chunk
     }
 
     private void scheduleNeighbours(final List<NewChunkHolder> needsScheduling, final List<ChunkProgressionTask> scheduleList) {
@@ -1862,6 +1901,7 @@ public final class NewChunkHolder {
         try {
             if (unloading) {
                 try {
+                    chunk.setUnsaved(false); // MultiPaper - set as saved before serializing
                     final ChunkSerializer.AsyncSaveData asyncSaveData = ChunkSerializer.getAsyncSaveData(this.world, chunk);
 
                     final PrioritisedExecutor.PrioritisedTask task = this.scheduler.loadExecutor.createTask(new AsyncChunkSerializeTask(this.world, chunk, asyncSaveData, this));
@@ -1870,7 +1910,7 @@ public final class NewChunkHolder {
 
                     task.queue();
 
-                    chunk.setUnsaved(false);
+                    // chunk.setUnsaved(false); // MultiPaper - set as saved before serializing
 
                     return true;
                 } catch (final ThreadDeath death) {
@@ -1881,6 +1921,7 @@ public final class NewChunkHolder {
                 }
             }
 
+            chunk.setUnsaved(false); // MultiPaper - set as saved before serializing
             final CompoundTag save = ChunkSerializer.saveChunk(this.world, chunk, null);
 
             if (unloading) {
@@ -1890,7 +1931,7 @@ public final class NewChunkHolder {
             } else {
                 RegionFileIOThread.scheduleSave(this.world, this.chunkX, this.chunkZ, save, RegionFileIOThread.RegionFileType.CHUNK_DATA);
             }
-            chunk.setUnsaved(false);
+            // chunk.setUnsaved(false); // MultiPaper - set as saved before serializing
         } catch (final ThreadDeath death) {
             throw death;
         } catch (final Throwable thr) {
diff --git a/src/main/java/net/minecraft/network/FriendlyByteBuf.java b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
index bdcfd80f937c34956911373905d66424bbff8e1d..e1a967b82661124f12826019e325be1bbffc38d2 100644
--- a/src/main/java/net/minecraft/network/FriendlyByteBuf.java
+++ b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
@@ -97,6 +97,8 @@ public class FriendlyByteBuf extends ByteBuf {
 
     public static boolean hasItemSerializeEvent = false; // Purpur
 
+    public long maxNbtSize = 2097152L; // MultiPaper
+
     public FriendlyByteBuf(ByteBuf parent) {
         this.source = parent;
     }
@@ -617,7 +619,7 @@ public class FriendlyByteBuf extends ByteBuf {
 
     @Nullable
     public CompoundTag readNbt() {
-        Tag nbtbase = this.readNbt(NbtAccounter.create(2097152L));
+        Tag nbtbase = this.readNbt(NbtAccounter.create(maxNbtSize));
 
         if (nbtbase != null && !(nbtbase instanceof CompoundTag)) {
             throw new DecoderException("Not a compound tag: " + nbtbase);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java
index 3944852921335c78a04a9dc301882ab5b152b1ed..90107814a68a401bda71d66bbec50eff6be727c0 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java
@@ -16,8 +16,12 @@ public class ClientboundBlockEntityDataPacket implements Packet<ClientGamePacket
     @Nullable
     private final CompoundTag tag;
 
+    public static ClientboundBlockEntityDataPacket create(BlockEntity blockEntity, Function<BlockEntity, CompoundTag> nbtGetter, boolean sanitizeNbt) {
+        return new ClientboundBlockEntityDataPacket(blockEntity.getBlockPos(), blockEntity.getType(), sanitizeNbt ? blockEntity.sanitizeSentNbt(nbtGetter.apply(blockEntity)) : nbtGetter.apply(blockEntity)); // MultiPaper - Skip nbt sanitization when syncing between servers
+    }
+
     public static ClientboundBlockEntityDataPacket create(BlockEntity blockEntity, Function<BlockEntity, CompoundTag> nbtGetter) {
-        return new ClientboundBlockEntityDataPacket(blockEntity.getBlockPos(), blockEntity.getType(), blockEntity.sanitizeSentNbt(nbtGetter.apply(blockEntity))); // Paper - Sanitize sent data
+        return create(blockEntity, nbtGetter, true); // MultiPaper - Sanitize sent data (Paper compatibility)
     }
 
     public static ClientboundBlockEntityDataPacket create(BlockEntity blockEntity) {
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index ef1de008f704fd88c6e05e6db6573206ceb1b270..1c95a74a218b0de2c79b00e67be4d2d07bd72ecf 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -14,6 +14,7 @@ import com.mojang.authlib.GameProfileRepository;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import java.awt.image.BufferedImage;
@@ -989,6 +990,21 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
         // CraftBukkit end
         this.getConnection().stop();
+        if (this.getConnection() != null) {
+            this.getConnection().stop();
+        }
+
+        // MultiPaper start
+        for (ServerLevel world : this.getAllLevels()) {
+            world.getChunkSource().entityTickingChunks.unsafeIterator().forEachRemaining(chunk -> {
+                NewChunkHolder chunkHolder = chunk.getChunkHolder();
+                if (chunkHolder.hasExternalLockRequest) {
+                    MultiPaper.unlockChunk(chunkHolder, chunk, chunkHolder.getEntityChunk());
+                }
+            });
+        }
+        // MultiPaper end
+
         this.isSaving = true;
         if (this.playerList != null) {
             MinecraftServer.LOGGER.info("Saving players");
@@ -1033,7 +1049,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         LOGGER.info("Flushing Chunk IO");
         // Paper end - move final shutdown items here
         io.papermc.paper.chunk.system.io.RegionFileIOThread.close(true); // Paper - rewrite chunk system
-        // Paper start - move final shutdown items here
+        LOGGER.info("Flushing MultiPaper Master connection"); // MultiPaper
+        MultiPaper.flushMasterConnectionAsync().join(); // MultiPaper
         LOGGER.info("Closing Thread Pool");
         Util.shutdownExecutors(); // Paper
         LOGGER.info("Closing Server");
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 627a88ec8c3b215b19b55a6d461c8754b4fcd1e8..8f3e031e3b1817688ec21499751342c2fc248c83 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -2,12 +2,14 @@ package net.minecraft.server.level;
 
 import com.mojang.datafixers.util.Either;
 import com.mojang.datafixers.util.Pair;
+import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
 import it.unimi.dsi.fastutil.shorts.ShortOpenHashSet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.List;
 import java.util.Optional;
+import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicReferenceArray;
@@ -18,6 +20,7 @@ import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
@@ -40,6 +43,9 @@ import net.minecraft.world.level.lighting.LevelLightEngine;
 import net.minecraft.server.MinecraftServer;
 // CraftBukkit end
 
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
+
 public class ChunkHolder {
 
     public static final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> UNLOADED_CHUNK = Either.right(ChunkHolder.ChunkLoadingFailure.UNLOADED);
@@ -55,6 +61,10 @@ public class ChunkHolder {
     private final DebugBuffer<ChunkHolder.ChunkSaveDebug> chunkToSaveHistory;
     // Paper - rewrite chunk system
     public final ChunkPos pos;
+    public boolean addChangesToPlayersOnly = false; // MultiPaper
+    private boolean broadcastingToOtherServersOnly = false; // MultiPaper
+    private boolean broadcastingToPlayersOnly = false; // MultiPaper
+    private @Nullable Set<BlockPos> blocksToBroadcastToPlayers = null; // MultiPaper
     private boolean hasChangedSections;
     private final ShortSet[] changedBlocksPerSection;
     private final BitSet blockChangedLightSectionFilter;
@@ -226,6 +236,7 @@ public class ChunkHolder {
     // Paper - rewrite chunk system
 
     public void blockChanged(BlockPos pos) {
+        if (addChangesToPlayersOnly && !MultiPaper.isChunkLocal(this.chunkMap.level.getChunkIfLoaded(pos))) { broadcastBlockToPlayersLater(pos); return; } // MultiPaper
         // Paper start - replace player chunk loader
         if (this.playersSentChunkTo.size() == 0) {
             return;
@@ -243,6 +254,8 @@ public class ChunkHolder {
             }
 
             this.changedBlocksPerSection[i].add(SectionPos.sectionRelativePos(pos));
+
+            if (blocksToBroadcastToPlayers != null && !blocksToBroadcastToPlayers.isEmpty()) blocksToBroadcastToPlayers.remove(pos); // MultiPaper
         }
     }
 
@@ -288,7 +301,44 @@ public class ChunkHolder {
     }
     // Paper end - optimise chunk tick iteration
 
+    // MultiPaper start
+    public void broadcastChangesToOtherServers(LevelChunk chunk) {
+        if (newChunkHolder.externalSubscribers.isEmpty()) return; // No point running this if no one's listening
+        broadcastingToOtherServersOnly = true;
+        broadcastChanges(chunk);
+        broadcastingToOtherServersOnly = false;
+    }
+
+    private void broadcastBlockToPlayersLater(BlockPos blockPos) {
+        if (blocksToBroadcastToPlayers == null) {
+            blocksToBroadcastToPlayers = new ObjectLinkedOpenHashSet<>();
+        }
+
+        if (blockPos instanceof BlockPos.MutableBlockPos) {
+            // Let's make it not mutable...
+            blockPos = new BlockPos(blockPos);
+        }
+
+        this.addToBroadcastMap();
+        blocksToBroadcastToPlayers.add(blockPos);
+    }
+    // MultiPaper end
+
     public void broadcastChanges(LevelChunk chunk) {
+        // MultiPaper start
+        if (!broadcastingToOtherServersOnly && blocksToBroadcastToPlayers != null && !blocksToBroadcastToPlayers.isEmpty()) {
+            // Send blocks to players that shouldn't be sent to other servers as they've already been sent to other servers
+            broadcastingToPlayersOnly = true;
+            blocksToBroadcastToPlayers.forEach(blockPos -> {
+                BlockState blockState = chunk.getLevel().getBlockState(blockPos);
+                this.broadcast(new ClientboundBlockUpdatePacket(blockPos, blockState), false);
+                this.broadcastBlockEntityIfNeeded(this.getPlayers(false), chunk.getLevel(), blockPos, blockState);
+            });
+            broadcastingToPlayersOnly = false;
+            blocksToBroadcastToPlayers.clear();
+        }
+        // MultiPaper end
+
         if (this.needsBroadcastChanges()) { // Paper - optimise chunk tick iteration; moved into above, other logic needs to call
             Level world = chunk.getLevel();
             List list;
@@ -305,6 +355,7 @@ public class ChunkHolder {
                 this.blockChangedLightSectionFilter.clear();
             }
 
+            if (!broadcastingToOtherServersOnly) // MultiPaper
             if (this.hasChangedSections) {
                 list = this.getPlayers(false); // Paper - rewrite chunk system
 
@@ -321,6 +372,7 @@ public class ChunkHolder {
                                 BlockPos blockposition = sectionposition.relativeToBlockPos(shortset.iterator().nextShort());
                                 BlockState iblockdata = world.getBlockState(blockposition);
 
+                                if (broadcastingToOtherServersOnly) broadcastBlockToPlayersLater(blockposition); // MultiPaper
                                 this.broadcast(list, new ClientboundBlockUpdatePacket(blockposition, iblockdata));
                                 this.broadcastBlockEntityIfNeeded(list, world, blockposition, iblockdata);
                             } else {
@@ -331,6 +383,7 @@ public class ChunkHolder {
                                 // CraftBukkit start
                                 List finalList = list;
                                 packetplayoutmultiblockchange.runUpdates((blockposition1, iblockdata1) -> {
+                                    if (broadcastingToOtherServersOnly) broadcastBlockToPlayersLater(blockposition1); // MultiPaper
                                     this.broadcastBlockEntityIfNeeded(finalList, world, blockposition1, iblockdata1);
                                     // CraftBukkit end
                                 });
@@ -360,6 +413,8 @@ public class ChunkHolder {
             if (packet != null) {
                 this.broadcast(players, packet);
             }
+
+            if(!broadcastingToPlayersOnly) MultiPaperChunkHandler.onBlockUpdate(newChunkHolder, ClientboundBlockEntityDataPacket.create(tileentity, BlockEntity::saveWithFullMetadata, false)); // MultiPaper - sync the full block with external servers
         }
 
     }
@@ -384,6 +439,13 @@ public class ChunkHolder {
     // Paper end - rewrite chunk system
 
     private void broadcast(List<ServerPlayer> players, Packet<?> packet) {
+        // MultiPaper start - Sync blocks with external servers
+        if (!broadcastingToPlayersOnly && !(packet instanceof ClientboundBlockEntityDataPacket)) { // We handle block entities separately
+            MultiPaperChunkHandler.onBlockUpdate(newChunkHolder, packet);
+        }
+        if (broadcastingToOtherServersOnly) return; // MultiPaper
+        // MultiPaper end
+
         players.forEach((entityplayer) -> {
             entityplayer.connection.send(packet);
         });
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 0b72267c1c42fc55c6c250b95d6dfd58ec84fcb6..cabd3acadcd8d49fb8dcfb207ef6b2fa6e764e7b 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -893,6 +893,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             return status;
         }
 
+        if (true) return null; // MultiPaper - Don't load chunk status from the disk
+
         this.readChunk(chunkPos);
 
         return regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 7b3ba500f465b999ce11964b0e4e30f36005536e..83ed70f4f3729e634c8538790d91a648b8806fa7 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -46,6 +46,8 @@ import net.minecraft.world.level.levelgen.RandomState;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
+import puregero.multipaper.MultiPaper;
 
 public class ServerChunkCache extends ChunkSource {
 
@@ -616,34 +618,18 @@ public class ServerChunkCache extends ChunkSource {
                     // Paper end - optimise chunk tick iteration
                     ChunkPos chunkcoordintpair = chunk1.getPos();
 
-                    // Paper start - optimise chunk tick iteration
-                    com.destroystokyo.paper.util.maplist.ReferenceList<ServerPlayer> playersNearby
-                        = nearbyPlayers.getPlayers(chunkcoordintpair, io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.SPAWN_RANGE);
-                    if (playersNearby == null) {
-                        continue;
-                    }
-                    Object[] rawData = playersNearby.getRawData();
-                    boolean spawn = false;
-                    boolean tick = false;
-                    for (int itr = 0, len = playersNearby.size(); itr < len; ++itr) {
-                        ServerPlayer player = (ServerPlayer)rawData[itr];
-                        if (player.isSpectator()) {
-                            continue;
-                        }
-
-                        double distance = ChunkMap.euclideanDistanceSquared(chunkcoordintpair, player);
-                        spawn |= player.lastEntitySpawnRadiusSquared >= distance;
-                        tick |= ((double)io.papermc.paper.util.player.NearbyPlayers.SPAWN_RANGE_VIEW_DISTANCE_BLOCKS) * ((double)io.papermc.paper.util.player.NearbyPlayers.SPAWN_RANGE_VIEW_DISTANCE_BLOCKS) >= distance;
-                        if (spawn & tick) {
-                            break;
-                        }
+                // MultiPaper start - Don't tick this chunk if we don't own it
+                boolean isTicking = chunkMap.getDistanceManager().inEntityTickingRange(chunkcoordintpair.longKey);
+                if (isTicking && !holder.newChunkHolder.hasExternalLockRequest) MultiPaper.lockChunk(holder.newChunkHolder);
+                if (!isTicking && holder.newChunkHolder.hasExternalLockRequest) MultiPaper.unlockChunk(holder.newChunkHolder, chunk1, holder.newChunkHolder.getEntityChunk());
+                if (!MultiPaper.isChunkLocal(chunk1)) continue;
+                // MultiPaper end - Don't tick this chunk if we don't own it
+
+                if ((true || this.level.isNaturalSpawningAllowed(chunkcoordintpair)) && this.chunkMap.anyPlayerCloseEnoughForSpawning(holder, chunkcoordintpair, false)) { // Paper - optimise anyPlayerCloseEnoughForSpawning // Paper - the chunk is known ticking
+                    chunk1.incrementInhabitedTime(j);
+                    if (flag2 && (!gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning || _pufferfish_spawnCountsReady.get()) && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair) && this.chunkMap.anyPlayerCloseEnoughForSpawning(holder, chunkcoordintpair, true)) { // Spigot // Paper - optimise anyPlayerCloseEnoughForSpawning & optimise chunk tick iteration
+                        NaturalSpawner.spawnForChunk(this.level, chunk1, lastSpawnState, this.spawnFriendlies, this.spawnEnemies, flag1); // Pufferfish
                     }
-                    if (tick && chunk1.chunkStatus.isOrAfter(net.minecraft.server.level.FullChunkStatus.ENTITY_TICKING)) {
-                        // Paper end - optimise chunk tick iteration
-                        chunk1.incrementInhabitedTime(j);
-                        if (spawn && flag && (!gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning || _pufferfish_spawnCountsReady.get()) && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair)) { // Spigot // Paper - optimise chunk tick iteration // Pufferfish
-                            NaturalSpawner.spawnForChunk(this.level, chunk1, lastSpawnState, this.spawnFriendlies, this.spawnEnemies, flag1); // Pufferfish
-                        }
 
                         if (true || this.level.shouldTickBlocksAt(chunkcoordintpair.toLong())) { // Paper - optimise chunk tick iteration
                             this.level.tickChunk(chunk1, l);
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 00ac2902be93327c7dd1bf78ee5922d7954f1b26..1c63f3dce271d866ad75c36b0cfb715ae00c2bf9 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -6,6 +6,7 @@ import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.MCUtil;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -178,6 +179,9 @@ import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.GenericGameEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
+import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
+import puregero.multipaper.MultiPaperChunkHandler;
 
 public class ServerLevel extends Level implements WorldGenLevel {
 
@@ -702,8 +706,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
         // CraftBukkit end
         this.players = Lists.newArrayList();
         this.entityTickList = new EntityTickList();
-        this.blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
-        this.fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
+        this.blockTicks = new LevelTicks<>(this, this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier()); // MultiPaper - add level
+        this.fluidTicks = new LevelTicks<>(this, this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier()); // MultiPaper - add level
         this.navigatingMobs = new ObjectOpenHashSet();
         this.blockEvents = new ObjectLinkedOpenHashSet();
         this.blockEventsToReschedule = new ArrayList(64);
@@ -2617,6 +2621,11 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 return;
             }
             // CraftBukkit end
+            // MultiPaper start - run neighbour updates later if we're handling block changes
+            if (MultiPaperChunkHandler.blockUpdateChunk != null) {
+                MCUtil.ensureMain(() -> this.updateNeighborsAt(pos, block));
+            } else
+            // MultiPaper end - run neighbour updates later if we're handling block changes
             this.updateNeighborsAt(pos, block);
         }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
index 61a06706f1468a8d4cceb9fb2aae61cf56bd991d..b827a8f3b101be7a4183634b85a381e8141a1ecb 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
@@ -34,6 +34,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.chunk.storage.SectionStorage;
+import puregero.multipaper.MultiPaper;
 
 public class PoiManager extends SectionStorage<PoiSection> {
     public static final int MAX_VILLAGE_DISTANCE = 6;
@@ -416,6 +417,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
     @javax.annotation.Nullable
     @Override
     public net.minecraft.nbt.CompoundTag read(ChunkPos chunkcoordintpair) throws java.io.IOException {
+        if (true) return MultiPaper.readRegionFileNBT(world, "poi", chunkcoordintpair); // MultiPaper
         // Paper start - rewrite chunk system
         if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
             return io.papermc.paper.chunk.system.io.RegionFileIOThread.loadData(
@@ -429,6 +431,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
 
     @Override
     public void write(ChunkPos chunkcoordintpair, net.minecraft.nbt.CompoundTag nbttagcompound) throws java.io.IOException {
+        if (true) MultiPaper.writeRegionFileNBT(world, "poi", chunkcoordintpair, nbttagcompound); // MultiPaper
         // Paper start - rewrite chunk system
         if (!io.papermc.paper.chunk.system.io.RegionFileIOThread.isRegionFileThread()) {
             io.papermc.paper.chunk.system.io.RegionFileIOThread.scheduleSave(
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 311c853f2150247350ab6ccb2dd92d58dbfc645c..97aa0062c7b36114c7135f1d8bd3d30b961b9271 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -100,6 +100,7 @@ import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.entity.SpawnCategory;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.world.GenericGameEvent;
+import puregero.multipaper.MultiPaperChunkHandler;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
@@ -1343,7 +1344,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 tilesThisCycle--;
                 toRemove.add(tickingblockentity); // Paper - Fix MC-117075; use removeAll
                 // Spigot end
-            } else if (flag && this.shouldTickBlocksAt(tickingblockentity.getPos())) {
+            } else if (this.shouldTickBlocksAt(tickingblockentity.getPos())) {
+                if (!MultiPaperChunkHandler.shouldTick(this, tickingblockentity.getPos())) continue; // MultiPaper - should tick
                 tickingblockentity.tick();
                 // Paper start - execute chunk tasks during tick
                 if ((this.tileTickPosition & 7) == 0) {
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
index e9701ed4e5b35ace1accd2b46f082191d8ab6497..d20cfa560339fffed467e39cfe9daf17188c0dc8 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
@@ -11,6 +11,7 @@ import net.minecraft.nbt.StringTag;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientGamePacketListener;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.item.BlockItem;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.Level;
@@ -42,12 +43,14 @@ public abstract class BlockEntity {
     protected final BlockPos worldPosition;
     protected boolean remove;
     private BlockState blockState;
+    public final ResourceLocation minecraftKey; // MultiPaper
 
     public BlockEntity(BlockEntityType<?> type, BlockPos pos, BlockState state) {
         this.type = type;
         this.worldPosition = pos.immutable();
         this.blockState = state;
         this.persistentDataContainer = new CraftPersistentDataContainer(DATA_TYPE_REGISTRY); // Paper - always init
+        this.minecraftKey = BlockEntityType.getKey(this.type); // MultiPaper
     }
 
     public static BlockPos getPosFromTag(CompoundTag nbt) {
@@ -188,6 +191,7 @@ public abstract class BlockEntity {
     }
 
     protected static void setChanged(Level world, BlockPos pos, BlockState state) {
+        ((ServerLevel) world).getChunkSource().blockChanged(pos); // MultiPaper
         world.blockEntityChanged(pos);
         if (!state.isAir()) {
             world.updateNeighbourForOutputSignal(pos, state.getBlock());
diff --git a/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java
index 9b2c162c362fcf6093a3bf6da715ae8f18176c82..1fca610e6c1b217c381a0befbf71342fa3ed348f 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java
@@ -29,5 +29,6 @@ public class ComparatorBlockEntity extends BlockEntity {
 
     public void setOutputSignal(int outputSignal) {
         this.output = outputSignal;
+        setChanged(); // MultiPaper
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
index be74adc86f0ca467f3b59e7b57fd47a8f381d86e..24652311d88d1479779e57cd3c90ae2f2f9b07aa 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -2,6 +2,8 @@ package net.minecraft.world.level.block.piston;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+
+import java.util.*;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.MapCodec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
@@ -42,7 +44,6 @@ import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 // CraftBukkit start
 import com.google.common.collect.ImmutableList;
-import java.util.AbstractList;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.event.block.BlockPistonRetractEvent;
 import org.bukkit.event.block.BlockPistonExtendEvent;
@@ -461,6 +462,7 @@ public class PistonBaseBlock extends DirectionalBlock {
                 }
                 // Paper end - fix a variety of piston desync dupes
                 aiblockdata[i++] = iblockdata1;
+                ((ServerLevel) world).getChunkSource().blockChanged(blockposition3); // MultiPaper
             }
 
             if (retract) {
@@ -471,6 +473,7 @@ public class PistonBaseBlock extends DirectionalBlock {
                 map.remove(blockposition1);
                 world.setBlock(blockposition1, iblockdata1, 68);
                 world.setBlockEntity(MovingPistonBlock.newMovingBlockEntity(blockposition1, iblockdata1, iblockdata3, dir, true, true));
+                ((ServerLevel) world).getChunkSource().blockChanged(blockposition1); // MultiPaper
             }
 
             BlockState iblockdata4 = Blocks.AIR.defaultBlockState();
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java b/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
index 9f45dda6ff45ac1ffb7ac99575b7d09bdc61c56a..73355f1fd8743f1e8739ab47721ea56b9ca0ca9e 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
@@ -9,6 +9,7 @@ import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtUtils;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
@@ -27,6 +28,7 @@ import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import puregero.multipaper.MultiPaper;
 
 public class PistonMovingBlockEntity extends BlockEntity {
     private static final int TICKS_TO_EXTEND = 2;
@@ -269,7 +271,7 @@ public class PistonMovingBlockEntity extends BlockEntity {
     }
 
     public void finalTick() {
-        if (this.level != null && (this.progressO < 1.0F || this.level.isClientSide)) {
+        if (this.level != null && (this.progressO < 1.0F || this.level.isClientSide) && !MultiPaper.isChunkExternal((ServerLevel) level, getBlockPos())) { // MultiPaper
             this.progress = 1.0F;
             this.progressO = this.progress;
             this.level.removeBlockEntity(this.worldPosition);
@@ -320,6 +322,8 @@ public class PistonMovingBlockEntity extends BlockEntity {
             if (blockEntity.progress >= 1.0F) {
                 blockEntity.progress = 1.0F;
             }
+
+            blockEntity.setChanged(); // MultiPaper
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/level/border/WorldBorder.java b/src/main/java/net/minecraft/world/level/border/WorldBorder.java
index 350aabd20329f429248c84d73ab8b5eb145943a7..81e0d9e1016a1d38631c0fe170e1ec59c1cc00a1 100644
--- a/src/main/java/net/minecraft/world/level/border/WorldBorder.java
+++ b/src/main/java/net/minecraft/world/level/border/WorldBorder.java
@@ -14,6 +14,7 @@ import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import puregero.multipaper.MultiPaperWorldBorderHandler;
 
 public class WorldBorder {
 
@@ -31,7 +32,7 @@ public class WorldBorder {
     public static final WorldBorder.Settings DEFAULT_SETTINGS = new WorldBorder.Settings(0.0D, 0.0D, 0.2D, 5.0D, 5, 15, 5.9999968E7D, 0L, 0.0D);
     public net.minecraft.server.level.ServerLevel world; // CraftBukkit
 
-    public WorldBorder() {}
+    public WorldBorder() { listeners.add(new MultiPaperWorldBorderHandler()); } // MultiPaper - Add our own world border listener
 
     public boolean isWithinBounds(BlockPos pos) {
         return (double) (pos.getX() + 1) > this.getMinX() && (double) pos.getX() < this.getMaxX() && (double) (pos.getZ() + 1) > this.getMinZ() && (double) pos.getZ() < this.getMaxZ();
@@ -304,6 +305,7 @@ public class WorldBorder {
     }
 
     public void applySettings(WorldBorder.Settings properties) {
+        MultiPaperWorldBorderHandler.updatingWorldBorder = true; // MultiPaper
         this.setCenter(properties.getCenterX(), properties.getCenterZ());
         this.setDamagePerBlock(properties.getDamagePerBlock());
         this.setDamageSafeZone(properties.getSafeZone());
@@ -314,7 +316,7 @@ public class WorldBorder {
         } else {
             this.setSize(properties.getSize());
         }
-
+        MultiPaperWorldBorderHandler.updatingWorldBorder = false; // MultiPaper
     }
 
     private class StaticBorderExtent implements WorldBorder.BorderExtent {
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
index f7e5e016a7028a9196e689e950805b0d5b31fe38..6da887db073eca3843155cd03b07eb90d5f448ea 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -60,7 +60,7 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final LongSet EMPTY_REFERENCE_SET = new LongOpenHashSet();
     protected final ShortList[] postProcessing;
-    protected volatile boolean unsaved;
+    public volatile boolean unsaved; // MultiPaper - make public
     private volatile boolean isLightCorrect;
     protected final ChunkPos chunkPos; public final long coordinateKey; public final int locX; public final int locZ; // Paper - cache coordinate key
     private long inhabitedTime;
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 97724cbd6c1bf172379e98d4a3f6e8cda5cda823..d12ecfb41800a5a8e610ed822ef85e7a92fbaa05 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -8,9 +8,10 @@ import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.shorts.ShortListIterator;
-import java.util.Iterator;
-import java.util.Map;
+
+import java.util.*;
 import java.util.Map.Entry;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
@@ -21,6 +22,7 @@ import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.game.ClientboundLevelChunkPacketData;
 import net.minecraft.server.level.FullChunkStatus;
@@ -51,6 +53,7 @@ import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.ticks.LevelChunkTicks;
 import net.minecraft.world.ticks.TickContainerAccess;
 import org.slf4j.Logger;
+import puregero.multipaper.*;
 
 public class LevelChunk extends ChunkAccess {
 
@@ -82,8 +85,10 @@ public class LevelChunk extends ChunkAccess {
     @Nullable
     private LevelChunk.PostLoadProcessor postLoad;
     private final Int2ObjectMap<GameEventListenerRegistry> gameEventListenerRegistrySections;
-    private final LevelChunkTicks<Block> blockTicks;
-    private final LevelChunkTicks<Fluid> fluidTicks;
+    @Nullable public ListTag entitiesToLoad; // MultiPaper
+    @Nullable public ListTag blockEntitiesToLoad; // MultiPaper
+    public LevelChunkTicks<Block> blockTicks; // MultiPaper - make public and non-final
+    public LevelChunkTicks<Fluid> fluidTicks; // MultiPaper - make public and non-final
     public volatile FullChunkStatus chunkStatus = FullChunkStatus.INACCESSIBLE; // Paper - rewrite chunk system
 
     // Pufferfish start - instead of using a random every time the chunk is ticked, define when lightning strikes preemptively
@@ -643,6 +648,12 @@ public class LevelChunk extends ChunkAccess {
 
     @Override
     public void removeBlockEntity(BlockPos pos) {
+        // MultiPaper start - allow removing a block entity on unloaded block entities
+        if (blockEntitiesToLoad != null) {
+            blockEntitiesToLoad.removeIf(tag -> pos.equals(BlockEntity.getPosFromTag((CompoundTag) tag)));
+        }
+        // MultiPaper end
+
         if (this.isInLevel()) {
             BlockEntity tileentity = (BlockEntity) this.blockEntities.remove(pos);
 
@@ -777,6 +788,7 @@ public class LevelChunk extends ChunkAccess {
 
     public void onChunkNotEntityTicking(io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder) {
         io.papermc.paper.chunk.system.ChunkSystem.onChunkNotEntityTicking(this, chunkHolder.vanillaChunkHolder);
+        if (chunkHolder.hasExternalLockRequest) MultiPaper.unlockChunk(chunkHolder, chunkHolder.getCurrentChunk(), chunkHolder.getEntityChunk());
     }
     // Paper end - new load callbacks
 
@@ -788,6 +800,7 @@ public class LevelChunk extends ChunkAccess {
         // Paper - rewrite chunk system - move into separate callback
         org.bukkit.Server server = this.level.getCraftServer();
         // Paper - rewrite chunk system - move into separate callback
+        MultiPaperChunkHandler.onChunkLoad(this); // MultiPaper
         if (server != null) {
             /*
              * If it's a new world, the first few chunks are generated inside
@@ -864,6 +877,7 @@ public class LevelChunk extends ChunkAccess {
 
     @Override
     public boolean isUnsaved() {
+        if (MultiPaper.isChunkExternal(this)) return false; // MultiPaper - only save if no one else owns it
         // Paper start - add dirty system to tick lists
         long gameTime = this.level.getLevelData().getGameTime();
         if (this.blockTicks.isDirty(gameTime) || this.fluidTicks.isDirty(gameTime)) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
index a1f6274c9b1ab02ee55f1ae6011fc2dbb6e4824f..480fe7c02d4a27b0ed7fa040e78507f67a074f3d 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
@@ -44,8 +44,8 @@ public class ProtoChunk extends ChunkAccess {
     private final Map<GenerationStep.Carving, CarvingMask> carvingMasks = new Object2ObjectArrayMap<>();
     @Nullable
     private BelowZeroRetrogen belowZeroRetrogen;
-    private final ProtoChunkTicks<Block> blockTicks;
-    private final ProtoChunkTicks<Fluid> fluidTicks;
+    public ProtoChunkTicks<Block> blockTicks; // MultiPaper - make public and non-final
+    public ProtoChunkTicks<Fluid> fluidTicks; // MultiPaper - make public and non-final
 
     public ProtoChunk(ChunkPos pos, UpgradeData upgradeData, LevelHeightAccessor world, Registry<Biome> biomeRegistry, @Nullable BlendingData blendingData) {
         this(pos, upgradeData, null, new ProtoChunkTicks<>(), new ProtoChunkTicks<>(), world, biomeRegistry, blendingData);
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
index d312ce27364f84d32dec8d58a2b37a8a6ad756af..8edb2f4a60d65b5ddf1c1792d21488ffe479e4fa 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
@@ -288,6 +288,10 @@ public class ChunkSerializer {
             object1 = new LevelChunk(world.getLevel(), chunkPos, chunkconverter, levelchunkticks, levelchunkticks1, l, achunksection, ChunkSerializer.postLoadChunk(world, nbt), blendingdata);
             ((LevelChunk)object1).setBlockNibbles(blockNibbles); // Paper - replace light impl
             ((LevelChunk)object1).setSkyNibbles(skyNibbles); // Paper - replace light impl
+            // MultiPaper start - Keep copy of entities and block entities until they're loaded
+            ((LevelChunk)object1).entitiesToLoad = ChunkSerializer.getListOfCompoundsOrNull(nbt, "entities");
+            ((LevelChunk)object1).blockEntitiesToLoad = ChunkSerializer.getListOfCompoundsOrNull(nbt, "block_entities");
+            // MultiPaper end
         } else {
             ProtoChunkTicks<Block> protochunkticklist = ProtoChunkTicks.load(nbt.getList("block_ticks", 10), (s) -> {
                 return BuiltInRegistries.BLOCK.getOptional(ResourceLocation.tryParse(s));
@@ -475,6 +479,8 @@ public class ChunkSerializer {
         DataResult<Tag> dataresult; // CraftBukkit - decompile error
         Logger logger;
 
+        if (chunk.unsaved) nbttagcompound.putBoolean("shouldSave", true); // MultiPaper
+
         if (blendingdata != null) {
             dataresult = BlendingData.CODEC.encodeStart(NbtOps.INSTANCE, blendingdata);
             logger = ChunkSerializer.LOGGER;
@@ -707,6 +713,10 @@ public class ChunkSerializer {
                 }
             }
 
+            // MultiPaper start - Keep copy of entities and block entities until they're loaded
+            chunk.entitiesToLoad = null;
+            chunk.blockEntitiesToLoad = null;
+            // MultiPaper end
         };
     }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
index c70f04cdee1e8ba6f8a15c9e38edbe0023b5ab96..f66a1e775813135858a25dc1ed612c8717434a2f 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
@@ -79,6 +79,7 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
             if (this.emptyChunks.add(chunkPos.toLong())) {
                 // Paper - rewrite chunk system
             }
+            this.emptyChunks.remove(chunkPos.toLong()); // MultiPaper - don't cache empty chunks
         } else {
             // Paper - move into saveEntityChunk0
             this.emptyChunks.remove(chunkPos.toLong());
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
index 6cf83502a954cce9c562ec036bfeddb477d38b73..8ee4533576717d016fb7b797b7f899f078644e6d 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -892,6 +892,7 @@ public class RegionFile implements AutoCloseable {
     }
 
     public boolean hasChunk(ChunkPos pos) {
+        if (true) return true; // MultiPaper - always return true
         return this.getOffset(pos) != 0;
     }
 
@@ -901,6 +902,12 @@ public class RegionFile implements AutoCloseable {
     }
 
     public void close() throws IOException {
+        // MultiPaper start
+        if (this.file == null) {
+            this.closed = true;
+            return;
+        }
+        // MultiPaper end
         // Paper start - Prevent regionfiles from being closed during use
         this.fileLock.lock();
         synchronized (this) {
diff --git a/src/main/java/net/minecraft/world/level/portal/PortalForcer.java b/src/main/java/net/minecraft/world/level/portal/PortalForcer.java
index 5d4c18b068f41f349bdccec14e08ca6ca7cb0c6c..0925e3fdadfea6e8a26bf9a544d714267844c924 100644
--- a/src/main/java/net/minecraft/world/level/portal/PortalForcer.java
+++ b/src/main/java/net/minecraft/world/level/portal/PortalForcer.java
@@ -58,7 +58,7 @@ public class PortalForcer {
             villageplace,
             type -> type.is(PoiTypes.NETHER_PORTAL),
             (BlockPos pos) -> {
-                net.minecraft.world.level.chunk.ChunkAccess lowest = this.level.getChunk(pos.getX() >> 4, pos.getZ() >> 4, net.minecraft.world.level.chunk.ChunkStatus.EMPTY);
+                net.minecraft.world.level.chunk.ChunkAccess lowest = this.level.getChunk(pos.getX() >> 4, pos.getZ() >> 4, net.minecraft.world.level.chunk.ChunkStatus.FULL); // MultiPaper - For some reason empty was reseting the chunks nearby the portal
                 if (!lowest.getStatus().isOrAfter(net.minecraft.world.level.chunk.ChunkStatus.FULL)
                     && (lowest.getBelowZeroRetrogen() == null || !lowest.getBelowZeroRetrogen().targetStatus().isOrAfter(net.minecraft.world.level.chunk.ChunkStatus.SPAWN))) {
                     // why would we generate the chunk?
diff --git a/src/main/java/net/minecraft/world/ticks/LevelTicks.java b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
index a6d62abd3102770652f914b9d697c6d3c2533cfc..d443a0fdf5e10de8bee651dffbc00b94a53c92af 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
@@ -24,9 +24,11 @@ import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.core.Vec3i;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
+import puregero.multipaper.MultiPaper;
 
 public class LevelTicks<T> implements LevelTickAccess<T> {
     private static final Comparator<LevelChunkTicks<?>> CONTAINER_DRAIN_ORDER = (a, b) -> ScheduledTick.INTRA_TICK_DRAIN_ORDER.compare(a.peek(), b.peek());
@@ -44,7 +46,10 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
         }
     };
 
-    public LevelTicks(LongPredicate tickingFutureReadyPredicate, Supplier<ProfilerFiller> profilerGetter) {
+    public ServerLevel level; // MultiPaper - add level
+
+    public LevelTicks(ServerLevel level, LongPredicate tickingFutureReadyPredicate, Supplier<ProfilerFiller> profilerGetter) { // MultiPaper - add level
+        this.level = level; // MultiPaper - add level
         this.tickCheck = tickingFutureReadyPredicate;
         this.profiler = profilerGetter;
     }
@@ -110,6 +115,10 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
                 LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(l);
                 if (levelChunkTicks == null) {
                     objectIterator.remove();
+                // MultiPaper start - Don't tick chunks that aren't owned by us
+                } else if (levelChunkTicks.count() > 0 && !MultiPaper.isChunkLocal(level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(l))) {
+                    levelChunkTicks.getAll().forEach(tick -> tick.triggerTick++);
+                // MultiPaper end - Don't tick chunks that aren't owned by us
                 } else {
                     ScheduledTick<T> scheduledTick = levelChunkTicks.peek();
                     if (scheduledTick == null) {
diff --git a/src/main/java/net/minecraft/world/ticks/ScheduledTick.java b/src/main/java/net/minecraft/world/ticks/ScheduledTick.java
index 6dc915f124df2d68e9383e5700bbe096847ea972..4844c84366bc058f81493a24db1a0c6f0c92ae76 100644
--- a/src/main/java/net/minecraft/world/ticks/ScheduledTick.java
+++ b/src/main/java/net/minecraft/world/ticks/ScheduledTick.java
@@ -5,7 +5,16 @@ import java.util.Comparator;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 
-public record ScheduledTick<T>(T type, BlockPos pos, long triggerTick, TickPriority priority, long subTickOrder) {
+// MultiPaper start - transform ScheduledTick from a record into a class
+public class ScheduledTick<T> {
+
+    public T type; public T type() { return type; }
+    public long triggerTick; public long triggerTick() { return triggerTick; }
+    public BlockPos pos; public BlockPos pos() { return pos; }
+    public TickPriority priority; public TickPriority priority() { return priority; }
+    public long subTickOrder; public long subTickOrder() { return subTickOrder; }
+// MultiPaper end
+
     public static final Comparator<ScheduledTick<?>> DRAIN_ORDER = (first, second) -> {
         int i = Long.compare(first.triggerTick, second.triggerTick);
         if (i != 0) {
diff --git a/src/main/java/puregero/multipaper/ChunkKey.java b/src/main/java/puregero/multipaper/ChunkKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..d139536be7ab15293b798af115e71a8dbe4a2f3d
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ChunkKey.java
@@ -0,0 +1,34 @@
+package puregero.multipaper;
+
+public class ChunkKey {
+    private final String name;
+    private final int x;
+    private final int z;
+
+    public ChunkKey(String name, int x, int z) {
+        this.name = name;
+        this.x = x;
+        this.z = z;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof ChunkKey) {
+            return ((ChunkKey) other).name.equals(name)
+                    && ((ChunkKey) other).x == x
+                    && ((ChunkKey) other).z == z;
+        }
+
+        return super.equals(other);
+    }
+
+    @Override
+    public int hashCode() {
+        // Taken from ChunkCoordIntPair
+        int i = 1664525 * this.x + 1013904223;
+        int j = 1664525 * (this.z ^ -559038737) + 1013904223;
+
+        return name.hashCode() ^ i ^ j;
+    }
+}
+
diff --git a/src/main/java/puregero/multipaper/ExternalServerConnection.java b/src/main/java/puregero/multipaper/ExternalServerConnection.java
index 9f1dca3645b4b9bf5eaf490cdde92abeac6a3c34..0f9d51e2959a9bf2b3b31930c88a942a777a6d56 100644
--- a/src/main/java/puregero/multipaper/ExternalServerConnection.java
+++ b/src/main/java/puregero/multipaper/ExternalServerConnection.java
@@ -21,9 +21,12 @@ import puregero.multipaper.mastermessagingprotocol.MessageLengthDecoder;
 import puregero.multipaper.mastermessagingprotocol.MessageLengthEncoder;
 
 import java.io.Closeable;
+import java.io.DataInputStream;
 import java.io.IOException;
 import java.util.*;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Consumer;
 
 public class ExternalServerConnection extends ChannelInitializer<SocketChannel> implements Closeable {
 
@@ -36,6 +39,9 @@ public class ExternalServerConnection extends ChannelInitializer<SocketChannel>
     public HashSet<String> subscribedWorlds = new HashSet<>();
     private static final Queue<List<ExternalPlayer>> externalPlayerListPool = new LinkedList<>();
     private final HashMap<Packet<?>, List<ExternalPlayer>> packetsToSend = new LinkedHashMap<>();
+    public final ConcurrentHashMap<ChunkKey, Consumer<DataInputStream>> chunkCallbacks = new ConcurrentHashMap<>();
+    public long lastPacketSent = 0;
+    public long lastPacketReceived = 0;
 
     public ExternalServerConnection() {
 
@@ -135,8 +141,10 @@ public class ExternalServerConnection extends ChannelInitializer<SocketChannel>
         } else {
             onConnect.thenRun(() -> {
                 if (channel.eventLoop().inEventLoop()) {
+                    lastPacketSent = System.currentTimeMillis();
                     channel.writeAndFlush(packet);
                 } else {
+                    lastPacketSent = System.currentTimeMillis();
                     channel.eventLoop().execute(() -> channel.writeAndFlush(packet));
                 }
             });
@@ -176,4 +184,16 @@ public class ExternalServerConnection extends ChannelInitializer<SocketChannel>
             players.add(player);
         }
     }
+
+    public void requestChunk(String world, int cx, int cz, Consumer<DataInputStream> callback) {
+        if (callback != null) {
+            if (chunkCallbacks.put(new ChunkKey(world, cx, cz), callback) != null) {
+                LOGGER.warn("A chunk callback already existed for " + world + ", " + cx + ", " + cz + " (new request is to " + externalServer.getName() + ")");
+                LOGGER.warn("Stats for " + externalServer.getName() + ": last packet sent=" + (System.currentTimeMillis() - lastPacketSent) + "ms ago; last packet received=" + (System.currentTimeMillis() - lastPacketReceived) + "ms ago");
+            }
+        }
+
+        RequestChunkPacket.blocker = externalServer;
+        send(new RequestChunkPacket(world, cx, cz));
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index 4779984056ebc27e737f2952d1a64acecff0f058..37c60e4235ccb8efd2f63c04d9470011f4c75d8e 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -1,32 +1,58 @@
 package puregero.multipaper;
 
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import io.papermc.paper.world.ChunkEntitySlices;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.Container;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtIo;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import org.bukkit.Bukkit;
+import org.bukkit.Chunk;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.event.inventory.InventoryCloseEvent;
+import puregero.multipaper.externalserverprotocol.*;
 import puregero.multipaper.externalserverprotocol.ExternalServerPacket;
 import puregero.multipaper.externalserverprotocol.PlayerCreatePacket;
 import puregero.multipaper.externalserverprotocol.PlayerRemovePacket;
-import puregero.multipaper.mastermessagingprotocol.messages.masterbound.PlayerConnectMessage;
-import puregero.multipaper.mastermessagingprotocol.messages.masterbound.PlayerDisconnectMessage;
-import puregero.multipaper.mastermessagingprotocol.messages.masterbound.StartMessage;
-import puregero.multipaper.mastermessagingprotocol.messages.masterbound.WriteTickTimeMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.*;
 import puregero.multipaper.mastermessagingprotocol.messages.serverbound.BooleanMessageReply;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.ChunkLoadedOnAnotherServerMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.DataMessageReply;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.ServerBoundMessage;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
+import java.io.DataInput;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
+import java.io.File;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
-import java.util.Collection;
+import java.util.*;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.InflaterInputStream;
 
 public class MultiPaper {
 
@@ -175,4 +201,240 @@ public class MultiPaper {
     public static CompoundTag nbtFromBytes(byte[] data) throws IOException {
         return NbtIo.read(new DataInputStream(new ByteArrayInputStream(data)));
     }
+
+    public static CompletableFuture<Void> flushMasterConnectionAsync() {
+        // Just read some random json file to ensure that all the queued packets in both directions have been fully flushed and handled
+        return MultiPaper.getConnection().sendAndAwaitReply(new ReadJsonMessage("ops.json"), DataMessageReply.class).thenRun(() -> {});
+    }
+
+    public static boolean isChunkExternal(Chunk chunk) {
+        return chunk != null && ((CraftChunk) chunk).getHandle(ChunkStatus.EMPTY) instanceof LevelChunk levelChunk && isChunkExternal(levelChunk);
+    }
+
+    public static boolean isChunkExternal(LevelChunk chunk) {
+        return chunk != null && isChunkExternal(chunk.getChunkHolder());
+    }
+
+    public static boolean isChunkExternal(ServerLevel level, BlockPos pos) {
+        return isChunkExternal(level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(ChunkPos.asLong(pos.getX() >> 4, pos.getZ() >> 4)));
+    }
+
+    public static boolean isChunkExternal(NewChunkHolder newChunkHolder) {
+        return newChunkHolder != null && newChunkHolder.externalOwner != null && !newChunkHolder.externalOwner.isMe();
+    }
+
+    public static boolean isChunkLocal(Chunk chunk) {
+        return chunk != null && ((CraftChunk) chunk).getHandle(ChunkStatus.EMPTY) instanceof LevelChunk levelChunk && isChunkLocal(levelChunk);
+    }
+
+    public static boolean isChunkLocal(LevelChunk chunk) {
+        return chunk != null && isChunkLocal(chunk.getChunkHolder());
+    }
+
+    public static boolean isChunkLocal(ServerLevel level, BlockPos pos) {
+        return isChunkLocal(level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(ChunkPos.asLong(pos.getX() >> 4, pos.getZ() >> 4)));
+    }
+
+    public static boolean isChunkLocal(NewChunkHolder newChunkHolder) {
+        return newChunkHolder != null && newChunkHolder.externalOwner != null && newChunkHolder.externalOwner.isMe();
+    }
+
+    public static CompoundTag readChunk(ChunkPos chunkPos, ServerLevel serverLevel) throws IOException {
+        return readRegionFileNBT(serverLevel, "region", chunkPos);
+    }
+
+    public static void writeChunk(ChunkPos chunkPos, ServerLevel serverLevel, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(serverLevel, "region", chunkPos, compoundTag);
+    }
+
+    public static CompletableFuture<byte[]> forceReadChunk(String world, String path, int cx, int cz) {
+        return getConnection().sendAndAwaitReply(new ForceReadChunkMessage(world, path, cx, cz), DataMessageReply.class).thenApply(message -> message.data);
+    }
+
+    public static CompletableFuture<DataInputStream> readRegionFileAsync(String world, String path, int cx, int cz) {
+        if (path.equals("region")) {
+            World bukkitWorld = Bukkit.getWorld(world);
+            if (bukkitWorld == null || MultiPaper.getChunkHolder(world, cx, cz) == null) {
+                if (Bukkit.getPluginManager().getPlugin("Dynmap") == null) {
+                    // Dynmap uses this, so don't log for Dynmap servers
+                    LOGGER.warn(Thread.currentThread() + " has no chunk holder for reading chunk " + world + "," + path + "," + cx + "," + cz + ", reading it straight from disk instead");
+                }
+
+                return forceReadChunk(world, path, cx, cz).thenApply(data -> data.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+            }
+        }
+
+        return getConnection().sendAndAwaitReply(new ReadChunkMessage(world, path, cx, cz), ServerBoundMessage.class).thenCompose(message -> {
+            if (message instanceof ChunkLoadedOnAnotherServerMessage chunkLoadedOnAnotherServerMessage) {
+                ExternalServer server = getConnection().getServersMap().get(chunkLoadedOnAnotherServerMessage.server);
+                CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+                if (server.getConnection() == null) {
+                    // Don't throw the exception as that will cause the chunk to get corrupted and regenerate, losing data. Instead, allow the chunk loader to naturally timeout and try again.
+                    new Exception("Tried to request a chunk " + world + "," + path + "," + cx + "," + cz + " from " + chunkLoadedOnAnotherServerMessage.server + ", but we are not connected to them!").printStackTrace();
+                } else if (path.equals("region")) {
+                    server.getConnection().requestChunk(world, cx, cz, inputStream -> {
+                        RequestChunkPacket.blocker = null;
+                        future.complete(inputStream);
+                    });
+                } else {
+                    throw new IllegalArgumentException("Cannot load a " + path + " chunk from an external server");
+                }
+                return future;
+            } else if (message instanceof DataMessageReply dataMessageReply) {
+                return CompletableFuture.completedFuture(dataMessageReply.data.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(dataMessageReply.data))));
+            } else {
+                throw new IllegalArgumentException("Unexpected message reply " + message);
+            }
+        });
+    }
+
+    public static DataInput readRegionFile(String world, String path, int cx, int cz) {
+        try {
+            return readRegionFileAsync(world, path, cx, cz).get(20, TimeUnit.SECONDS);
+        } catch (TimeoutException timeoutException) {
+            LOGGER.warn("Timed out reading " + world + "," + path + "," + cx + "," + cz + ", retrying...");
+            return readRegionFile(world, path, cx, cz);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void writeRegionFile(String world, String path, int cx, int cz, byte[] bytes) throws IOException {
+        writeRegionFile(world, path, cx, cz, bytes, false);
+    }
+
+    public static void writeRegionFile(String world, String path, int cx, int cz, byte[] bytes, boolean isTransientEntities) throws IOException {
+        if (bytes.length > 0) {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            DeflaterOutputStream deflateOut = new DeflaterOutputStream(baos);
+            deflateOut.write(bytes);
+            deflateOut.close();
+            bytes = baos.toByteArray();
+        }
+
+        getConnection().send(new WriteChunkMessage(world, path, cx, cz, bytes, isTransientEntities), message -> { /* Do nothing */ });
+    }
+
+    public static CompoundTag readRegionFileNBT(File path, ChunkPos chunkPos) throws IOException {
+        return readRegionFileNBT(getWorld(path), path.getName(), chunkPos.x, chunkPos.z);
+    }
+
+    public static CompoundTag readRegionFileNBT(ServerLevel serverLevel, String path, ChunkPos chunkPos) throws IOException {
+        return readRegionFileNBT(serverLevel.getWorld().getName(), path, chunkPos.x, chunkPos.z);
+    }
+
+    public static CompoundTag readRegionFileNBT(String world, String path, int cx, int cz) throws IOException {
+        DataInput in = readRegionFile(world, path, cx, cz);
+
+        return in == null ? null : NbtIo.read(in);
+    }
+
+    public static void writeRegionFileNBT(File path, ChunkPos chunkPos, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(getWorld(path), path.getName(), chunkPos.x, chunkPos.z, compoundTag);
+    }
+
+    public static void writeRegionFileNBT(ServerLevel serverLevel, String path, ChunkPos chunkPos, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(serverLevel.getWorld().getName(), path, chunkPos.x, chunkPos.z, compoundTag);
+    }
+
+    public static void writeRegionFileNBT(String world, String path, int cx, int cz, CompoundTag compoundTag) throws IOException {
+        writeRegionFile(world, path, cx, cz, nbtToBytes(compoundTag));
+    }
+
+    private static String getWorld(File path) {
+        do {
+            path = path.getParentFile();
+        } while (path.getName().startsWith("DIM"));
+        return path.getName();
+    }
+
+    public static void lockChunk(NewChunkHolder newChunkHolder) {
+        getConnection().send(new LockChunkMessage(newChunkHolder.world.getWorld().getName(), newChunkHolder.chunkX, newChunkHolder.chunkZ));
+        newChunkHolder.hasExternalLockRequest = true;
+    }
+
+    public static void unlockChunk(NewChunkHolder newChunkHolder, ChunkAccess chunkAccess, ChunkEntitySlices chunkEntitySlices) {
+        if (chunkAccess instanceof LevelChunk levelChunk && MultiPaper.isChunkLocal(newChunkHolder)) {
+            broadcastPacketToExternalServers(newChunkHolder.externalSubscribers, () -> new SendTickListPacket(levelChunk));
+            for (BlockEntity blockEntity : levelChunk.getBlockEntities().values()) {
+                if (blockEntity instanceof Container container) {
+                    List<HumanEntity> viewers = container.getViewers();
+                    if (!viewers.isEmpty()) {
+                        for (HumanEntity viewer : new ArrayList<>(container.getViewers())) {
+                            if (viewer instanceof CraftPlayer craftPlayer) {
+                                craftPlayer.closeInventory(InventoryCloseEvent.Reason.UNLOADED);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        getConnection().send(new UnlockChunkMessage(newChunkHolder.world.getWorld().getName(), newChunkHolder.chunkX, newChunkHolder.chunkZ));
+        newChunkHolder.externalOwner = null;
+        newChunkHolder.hasExternalLockRequest = false;
+    }
+
+    public static byte[] nbtCompressToBytes(CompoundTag compoundTag) throws IOException {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(buffer);
+        NbtIo.write(compoundTag, new DataOutputStream(deflaterOutputStream));
+        deflaterOutputStream.close();
+        return buffer.toByteArray();
+    }
+
+    public static CompoundTag nbtDecompressFromBytes(byte[] data) throws IOException {
+        return NbtIo.read(new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+    }
+
+    public static ChunkAccess getChunkAccess(String world, int cx, int cz) {
+        CraftWorld bukkitWorld = ((CraftWorld) Bukkit.getWorld(world));
+
+        ChunkAccess chunkAccess = bukkitWorld != null ? bukkitWorld.getHandle().getChunkIfLoaded(cx, cz) : null;
+        if (chunkAccess == null) {
+            NewChunkHolder holder = getChunkHolder(world, cx, cz);
+            if (holder != null) {
+                chunkAccess = holder.getCurrentChunk();
+
+                if (chunkAccess instanceof ImposterProtoChunk) {
+                    chunkAccess = ((ImposterProtoChunk) chunkAccess).getWrapped();
+                }
+            }
+        }
+
+        return chunkAccess;
+    }
+
+    public static ChunkAccess getChunkAccess(String world, BlockPos pos) {
+        return getChunkAccess(world, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static NewChunkHolder getChunkHolder(String world, BlockPos pos) {
+        return getChunkHolder(world, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static NewChunkHolder getChunkHolder(UUID world, BlockPos pos) {
+        return getChunkHolder(world, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static NewChunkHolder getChunkHolder(ServerLevel level, BlockPos pos) {
+        return getChunkHolder(level, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static NewChunkHolder getChunkHolder(String world, int x, int z) {
+        CraftWorld craftWorld = ((CraftWorld) Bukkit.getWorld(world));
+        return craftWorld != null ? getChunkHolder(craftWorld.getHandle(), x, z) : null;
+    }
+
+    public static NewChunkHolder getChunkHolder(UUID world, int x, int z) {
+        CraftWorld craftWorld = ((CraftWorld) Bukkit.getWorld(world));
+        return craftWorld != null ? getChunkHolder(craftWorld.getHandle(), x, z) : null;
+    }
+
+    public static NewChunkHolder getChunkHolder(ServerLevel level, int x, int z) {
+        return level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(x, z);
+    }
+
+    public static void chunkChangedStatus(ServerLevel level, ChunkPos pos, ChunkStatus status) {
+        getConnection().send(new ChunkChangedStatusMessage(level.getWorld().getName(), pos.x, pos.z, BuiltInRegistries.CHUNK_STATUS.getKey(status).toString()));
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java b/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..71d18b7b85c4df18b8d7e3fc959be67653278993
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java
@@ -0,0 +1,251 @@
+package puregero.multipaper;
+
+import ca.spottedleaf.starlight.common.light.SWMRNibbleArray;
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import io.papermc.paper.util.MCUtil;
+import io.papermc.paper.world.ChunkEntitySlices;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LightLayer;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.lighting.LevelLightEngine;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.externalserverprotocol.SendUpdatePacket;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.SubscribeChunkMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.UnsubscribeChunkMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.serverbound.BooleanMessageReply;
+
+import javax.annotation.Nullable;
+import java.util.BitSet;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.UUID;
+
+public class MultiPaperChunkHandler {
+
+    private static final Logger LOGGER = LogManager.getLogger(MultiPaperChunkHandler.class.getSimpleName());
+
+    public static boolean shouldTick(Level level, BlockPos pos) {
+        LevelChunk chunk = level.getChunkIfLoaded(pos);
+        return MultiPaper.isChunkLocal(chunk);
+    }
+
+    public static void onChunkLoad(LevelChunk chunk) {
+
+    }
+
+    public static void onChunkUnload(NewChunkHolder newChunkHolder, @Nullable ChunkAccess chunk, @Nullable ChunkEntitySlices chunkEntitySlices) {
+        if (newChunkHolder.hasExternalLockRequest) {
+            MultiPaper.unlockChunk(newChunkHolder, chunk, chunkEntitySlices);
+        }
+        MultiPaper.getConnection().sendAndAwaitReply(new UnsubscribeChunkMessage(newChunkHolder.world.getWorld().getName(), newChunkHolder.chunkX, newChunkHolder.chunkZ), BooleanMessageReply.class).thenRun(() ->
+            onChunkUnsubscribed(newChunkHolder.world.getWorld().getName(), newChunkHolder.chunkX, newChunkHolder.chunkZ)
+        );
+    }
+
+    public static void onChunkUnsubscribed(String world, int cx, int cz) {
+        NewChunkHolder holder = MultiPaper.getChunkHolder(world, cx, cz);
+
+        if (holder != null && holder.getCurrentChunk() != null) {
+            LOGGER.warn("Chunk " + world + "," + cx + "," + cz + " was unsubscribed from but has a chunk loaded! Resubscribing...");
+            MultiPaper.getConnection().send(new SubscribeChunkMessage(world, cx, cz));
+        }
+    }
+
+    private static final HashSet<BlockEntity> blockEntitiesToBroadcast = new HashSet<>();
+    public static void broadcastBlockEntityChange(BlockEntity entity) {
+        if (blockUpdateChunk != null) return; // Don't broadcast the update to other servers if we're handling an update
+        blockEntitiesToBroadcast.add(entity);
+        // Wait a bit as the block entity may get changed multiple times in 1 tick
+        MultiPaper.runSync(() -> {
+            for (BlockEntity blockEntity : blockEntitiesToBroadcast) {
+                if (blockEntity != null && blockEntity.getLevel() != null) {
+                    onBlockUpdate(MultiPaper.getChunkHolder(blockEntity.getLevel().getWorld().getName(), blockEntity.getBlockPos()), ClientboundBlockEntityDataPacket.create(blockEntity, BlockEntity::saveWithFullMetadata, false));
+                }
+            }
+            blockEntitiesToBroadcast.clear();
+        });
+    }
+
+    public static void onBlockUpdate(NewChunkHolder newChunkHolder, Packet<?> packet) {
+        if (newChunkHolder == null) {
+            // Chunk is still loading
+            return;
+        }
+
+        ChunkAccess chunk = newChunkHolder.getCurrentChunk();
+
+        if (chunk instanceof ImposterProtoChunk imposterProtoChunk) {
+            chunk = imposterProtoChunk.getWrapped();
+        }
+
+        if (chunk == null) {
+            LOGGER.warn("A " + packet.getClass().getSimpleName() + " occurred on an unloaded chunk " + newChunkHolder);
+            return;
+        }
+        if (blockUpdateChunk == null) { // Don't broadcast the update to other servers if we're handling an update
+            MultiPaper.broadcastPacketToExternalServers(newChunkHolder.externalSubscribers, () -> new SendUpdatePacket(newChunkHolder.world.uuid, packet));
+        }
+    }
+
+    public static ChunkAccess blockUpdateChunk = null;
+    private static NewChunkHolder holder = null;
+    public static void handleBlockUpdate(UUID world, Packet<?> packet, int depth) {
+        holder = null;
+        blockUpdateChunk = null;
+        ChunkAccess tempChunk = null;
+        CraftWorld bukkitWorld = ((CraftWorld) Bukkit.getWorld(world));
+        ServerLevel level = bukkitWorld != null ? bukkitWorld.getHandle() : null;
+        if (level == null) {
+            return;
+        } else if (packet instanceof ClientboundBlockUpdatePacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getPos());
+        } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+            update.runUpdates((pos, state) -> {
+                if (holder == null) holder = MultiPaper.getChunkHolder(world, pos);
+            });
+        } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getPos());
+        } else if (packet instanceof ClientboundLightUpdatePacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getX(), update.getZ());
+        }
+
+        if (holder != null && holder.hasGenerationTask()) {
+            holder.onCurrentChunkLoaded().thenRun(() -> {
+                if (!Bukkit.isPrimaryThread()) {
+                    new Exception("Loaded chunk " + holder.chunkX + "," + holder.chunkZ + ", outside of the main thread! (currentThread=" + Thread.currentThread() + ")").printStackTrace();
+                }
+                handleBlockUpdate(world, packet, depth);
+            });
+            return;
+        }
+
+        if (holder != null) {
+            tempChunk = holder.getCurrentChunk();
+
+            if (tempChunk instanceof ImposterProtoChunk imposterProtoChunk) {
+                tempChunk = imposterProtoChunk.getWrapped();
+            }
+        }
+
+        if (holder != null) {
+            // Only send changes we make below to players, not other servers
+            holder.vanillaChunkHolder.addChangesToPlayersOnly = true;
+        }
+
+        // Set blockUpdateChunk here so that we can broadcast changes beforehand
+        blockUpdateChunk = tempChunk;
+
+        if (holder != null && level.getChunkIfLoaded(holder.chunkX, holder.chunkZ) != null) {
+            // Chunk is loaded
+            if (packet instanceof ClientboundBlockUpdatePacket update) {
+                setBlock(((LevelChunk) blockUpdateChunk), update.getPos(), update.getBlockState());
+            } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+                update.runUpdates((pos, state) -> {
+                    setBlock(((LevelChunk) blockUpdateChunk), pos, state);
+                });
+            } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+                BlockEntity existingBlockEntity = blockUpdateChunk.getBlockEntity(update.getPos());
+                if (existingBlockEntity != null && existingBlockEntity.minecraftKey.toString().equals(update.getTag().getString("id"))) {
+                    existingBlockEntity.load(update.getTag());
+                    holder.vanillaChunkHolder.blockChanged(update.getPos());
+                } else if (!blockUpdateChunk.getBlockState(update.getPos()).hasBlockEntity() && depth < 1) {
+                    MCUtil.scheduleTask(1, () -> handleBlockUpdate(world, packet, depth + 1));
+                } else {
+                    blockUpdateChunk.removeBlockEntity(update.getPos());
+                    blockUpdateChunk.setBlockEntityNbt(update.getTag());
+                    blockUpdateChunk.getBlockEntity(update.getPos());
+                    holder.vanillaChunkHolder.blockChanged(update.getPos());
+                }
+            }
+        } else if (blockUpdateChunk != null) {
+            // Chunk is not loaded
+            if (packet instanceof ClientboundBlockUpdatePacket update) {
+                setBlockInUnloadedChunk(blockUpdateChunk, update.getPos(), update.getBlockState());
+            } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+                update.runUpdates((pos, state) -> {
+                    setBlockInUnloadedChunk(blockUpdateChunk, pos, state);
+                });
+            } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+                blockUpdateChunk.removeBlockEntity(update.getPos());
+                if (blockUpdateChunk instanceof LevelChunk levelChunk && levelChunk.blockEntitiesToLoad != null) {
+                    levelChunk.blockEntitiesToLoad.add(update.getTag());
+                } else {
+                    blockUpdateChunk.setBlockEntityNbt(update.getTag());
+                    blockUpdateChunk.getBlockEntity(update.getPos());
+                }
+            } else if (packet instanceof ClientboundLightUpdatePacket update) {
+                handleLightUpdatePacket(level, blockUpdateChunk, update);
+            }
+        }
+
+        if (holder != null) {
+            holder.vanillaChunkHolder.addChangesToPlayersOnly = false;
+        }
+
+        blockUpdateChunk = null;
+    }
+
+    private static void setBlockInUnloadedChunk(ChunkAccess chunk, BlockPos pos, BlockState blockState) {
+        if (chunk instanceof LevelChunk levelChunk) {
+            levelChunk.setBlockState(pos, blockState, false, false);
+        } else {
+            chunk.setBlockState(pos, blockState, false);
+        }
+    }
+
+    private static void setBlock(LevelChunk chunk, BlockPos pos, BlockState blockState) {
+        BlockState oldState = chunk.setBlockState(pos, blockState, false, false);
+        holder.vanillaChunkHolder.blockChanged(pos);
+
+        if (oldState != null && blockState != oldState && (blockState.getLightBlock(chunk, pos) != oldState.getLightBlock(chunk, pos) || blockState.getLightEmission() != oldState.getLightEmission() || blockState.useShapeForLightOcclusion() || oldState.useShapeForLightOcclusion())) {
+            chunk.level.getProfiler().push("queueCheckLightExternalUpdate");
+            chunk.level.getChunkSource().getLightEngine().checkBlock(pos);
+            chunk.level.getProfiler().pop();
+        }
+    }
+
+    // From the client
+    private static void handleLightUpdatePacket(ServerLevel level, ChunkAccess chunk, ClientboundLightUpdatePacket packet) {
+        int i = packet.getX();
+        int j = packet.getZ();
+        LevelLightEngine levellightengine = level.getChunkSource().getLightEngine();
+        BitSet bitset = packet.getLightData().getSkyYMask();
+        BitSet bitset1 = packet.getLightData().getEmptySkyYMask();
+        Iterator<byte[]> iterator = packet.getLightData().getSkyUpdates().iterator();
+        readSectionList(chunk, i, j, levellightengine, LightLayer.SKY, bitset, bitset1, iterator);
+        BitSet bitset2 = packet.getLightData().getBlockYMask();
+        BitSet bitset3 = packet.getLightData().getEmptyBlockYMask();
+        Iterator<byte[]> iterator1 = packet.getLightData().getBlockUpdates().iterator();
+        readSectionList(chunk, i, j, levellightengine, LightLayer.BLOCK, bitset2, bitset3, iterator1);
+    }
+
+    // From the client
+    private static void readSectionList(ChunkAccess chunk, int i, int j, LevelLightEngine levelLightEngine, LightLayer lightLayer, BitSet bitset2, BitSet bitset3, Iterator<byte[]> iterator1) {
+        for(int k = 0; k < levelLightEngine.getLightSectionCount(); ++k) {
+            int l = levelLightEngine.getMinLightSection() + k;
+            boolean flag = bitset2.get(k);
+            boolean flag1 = bitset3.get(k);
+            if (flag || flag1) {
+                if (lightLayer == LightLayer.BLOCK) {
+                    chunk.getBlockNibbles()[k] = flag ? new SWMRNibbleArray(iterator1.next().clone()) : new SWMRNibbleArray();
+                } else if (lightLayer == LightLayer.SKY) {
+                    chunk.getSkyNibbles()[k] = flag ? new SWMRNibbleArray(iterator1.next().clone()) : new SWMRNibbleArray();
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
index 9c4b6ba2479b79d034a52bc695327db83560a48c..51509e40ba4733c318b13f9821274ae701494b6e 100644
--- a/src/main/java/puregero/multipaper/MultiPaperConnection.java
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -9,15 +9,23 @@ import io.netty.channel.epoll.EpollEventLoopGroup;
 import io.netty.channel.epoll.EpollSocketChannel;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.LevelChunk;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import puregero.multipaper.config.MultiPaperConfiguration;
+import puregero.multipaper.externalserverprotocol.SendChunkPacket;
+import puregero.multipaper.externalserverprotocol.SendTickListPacket;
 import puregero.multipaper.mastermessagingprotocol.MessageBootstrap;
-import puregero.multipaper.mastermessagingprotocol.messages.masterbound.HelloMessage;
-import puregero.multipaper.mastermessagingprotocol.messages.masterbound.MasterBoundMessage;
-import puregero.multipaper.mastermessagingprotocol.messages.masterbound.MasterBoundProtocol;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.*;
 import puregero.multipaper.mastermessagingprotocol.messages.serverbound.*;
+
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
@@ -73,6 +81,15 @@ public class MultiPaperConnection extends ServerBoundMessageHandler {
         for (MasterBoundMessage unhandledRequest : unhandledRequests) {
             channel.write(unhandledRequest);
         }
+
+        if (MinecraftServer.getServer() != null) {
+            for (ServerLevel level : MinecraftServer.getServer().getAllLevels()) {
+                level.chunkTaskScheduler.chunkHolderManager.getChunkHolders().forEach(chunkHolder -> {
+                    channel.write(new SubscribeChunkMessage(level.getWorld().getName(), chunkHolder.chunkX, chunkHolder.chunkZ));
+                });
+            }
+        }
+
         channelActive = true;
         channel.flush();
     }
@@ -104,6 +121,21 @@ public class MultiPaperConnection extends ServerBoundMessageHandler {
             callback.accept(reply);
         }));
     }
+
+    public <T extends ServerBoundMessage> CompletableFuture<T> sendAndAwaitReply(MasterBoundMessage message, Class<T> expectedClass) {
+        CompletableFuture<T> future = new CompletableFuture<>();
+
+        send(message, reply -> {
+            try {
+                future.complete((T) reply);
+            } catch (ClassCastException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
     public Map<String, ExternalServer> getServersMap() {
         return serversMap;
     }
@@ -149,4 +181,104 @@ public class MultiPaperConnection extends ServerBoundMessageHandler {
             }
         });
     }
+
+    @Override
+    public void handle(SetChunkOwnerMessage message) {
+        ExternalServer server = message.owner.isEmpty() ? null : getOrCreateServer(message.owner);
+
+        NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(message.world, message.cx, message.cz);
+        if (newChunkHolder != null) {
+            if (newChunkHolder.externalOwner != null && newChunkHolder.externalOwner.isMe() && server != null && !server.isMe()) {
+                if (newChunkHolder.getCurrentChunk() instanceof LevelChunk levelChunk) {
+                    server.getConnection().send(new SendTickListPacket(levelChunk));
+                } else {
+                    LOGGER.warn("Chunk " + message.cx + ", " + message.cz + " in world " + message.world + " is not a level chunk, but we own it and want to send tick list to " + server.getName());
+                }
+            }
+            if (server != null && server.isMe()) {
+                // Wait a bit for extra data to arrive before ticking the chunk
+                newChunkHolder.externalOwner = null;
+                MultiPaper.runSync(() -> newChunkHolder.externalOwner = server);
+            } else if (server != null) {
+                newChunkHolder.externalOwner = server;
+                MultiPaper.runSync(() -> {
+                    if (newChunkHolder.getCurrentChunk() instanceof LevelChunk levelChunk) {
+                        levelChunk.blockTicks.removeIf(tick -> true);
+                        levelChunk.fluidTicks.removeIf(tick -> true);
+                    }
+                });
+            } else {
+                newChunkHolder.externalOwner = null;
+            }
+            if (server != null && newChunkHolder.getCurrentChunk() != null && newChunkHolder.getCurrentChunk().getStatus() != ChunkStatus.FULL) {
+                // A server has locked the chunk, which means their chunk must be full.
+                // Let's redownload their full copy
+                SendChunkPacket.forceChunkUnsafeUnload(message.world, message.cx, message.cz);
+            }
+        }
+
+    }
+
+    @Override
+    public void handle(AddChunkSubscriberMessage message) {
+        ExternalServer server = getOrCreateServer(message.server);
+
+        MultiPaper.runSync(() -> {
+            NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(message.world, message.cx, message.cz);
+            if (newChunkHolder != null) {
+                newChunkHolder.externalSubscribers.add(server);
+            } else {
+                LOGGER.warn("Received AddChunkSubscriberMessage for unloaded chunk " + message.world + " " + message.cx + " " + message.cz);
+            }
+        });
+    }
+
+    @Override
+    public void handle(RemoveChunkSubscriberMessage message) {
+        ExternalServer server = getOrCreateServer(message.server);
+
+        MultiPaper.runSync(() -> {
+            NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(message.world, message.cx, message.cz);
+            if (newChunkHolder != null) {
+                newChunkHolder.externalSubscribers.remove(server);
+            } else {
+                LOGGER.warn("Received RemoveChunkSubscriberMessage for unloaded chunk " + message.world + " " + message.cx + " " + message.cz);
+            }
+        });
+    }
+
+    @Override
+    public void handle(ChunkSubscribersSyncMessage message) {
+        ExternalServer ownerServer = message.owner.isEmpty() ? null : getOrCreateServer(message.owner);
+        HashSet<ExternalServer> servers = new HashSet<>();
+        for (String server : message.subscribers) {
+            servers.add(getOrCreateServer(server));
+        }
+
+        MultiPaper.runSync(() -> {
+            NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(message.world, message.cx, message.cz);
+            if (newChunkHolder != null) {
+                newChunkHolder.externalOwner = ownerServer;
+                newChunkHolder.externalSubscribers.clear();
+                newChunkHolder.externalSubscribers.addAll(servers);
+            } else {
+                LOGGER.warn("Received ChunkSubscribersSyncMessage for unloaded chunk " + message.world + " " + message.cx + " " + message.cz);
+            }
+        });
+    }
+
+    @Override
+    public void handle(ServerChangedChunkStatusMessage message) {
+        ExternalServer server = getOrCreateServer(message.server);
+        ChunkStatus status = BuiltInRegistries.CHUNK_STATUS.get(new ResourceLocation(message.status));
+
+        if (!server.isMe()) {
+            NewChunkHolder holder = MultiPaper.getChunkHolder(message.world, message.cx, message.cz);
+            if (holder == null) {
+                LOGGER.warn("Received a chunk change status notification for an unloaded chunk " + message.world + ";" + message.cx + ";" + message.cz + " from " + server.getName());
+            } else if (holder.getCurrentChunk() != null && !holder.getCurrentChunk().getStatus().isOrAfter(status)) {
+                SendChunkPacket.forceChunkUnsafeUnload(message.world, message.cx, message.cz);
+            }
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/puregero/multipaper/MultiPaperWorldBorderHandler.java b/src/main/java/puregero/multipaper/MultiPaperWorldBorderHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..229506e75000777a5c3c686533eac47ef17b30d4
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperWorldBorderHandler.java
@@ -0,0 +1,78 @@
+package puregero.multipaper;
+
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.*;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.border.BorderChangeListener;
+import net.minecraft.world.level.border.WorldBorder;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.jetbrains.annotations.NotNull;
+import puregero.multipaper.externalserverprotocol.SendUpdatePacket;
+
+import java.util.UUID;
+
+public class MultiPaperWorldBorderHandler implements BorderChangeListener {
+
+    public static boolean updatingWorldBorder = false;
+
+    @Override
+    public void onBorderSizeSet(@NotNull WorldBorder border, double size) {
+        onWorldBorderChange(border, new ClientboundSetBorderSizePacket(border));
+    }
+
+    @Override
+    public void onBorderSizeLerping(@NotNull WorldBorder border, double fromSize, double toSize, long time) {
+        onWorldBorderChange(border, new ClientboundSetBorderLerpSizePacket(border));
+    }
+
+    @Override
+    public void onBorderCenterSet(@NotNull WorldBorder border, double centerX, double centerZ) {
+        onWorldBorderChange(border, new ClientboundSetBorderCenterPacket(border));
+    }
+
+    @Override
+    public void onBorderSetWarningTime(@NotNull WorldBorder border, int warningTime) {
+        onWorldBorderChange(border, new ClientboundSetBorderWarningDelayPacket(border));
+    }
+
+    @Override
+    public void onBorderSetWarningBlocks(@NotNull WorldBorder border, int warningBlockDistance) {
+        onWorldBorderChange(border, new ClientboundSetBorderWarningDistancePacket(border));
+    }
+
+    @Override
+    public void onBorderSetDamagePerBlock(@NotNull WorldBorder border, double damagePerBlock) {}
+
+    @Override
+    public void onBorderSetDamageSafeZOne(@NotNull WorldBorder border, double safeZoneRadius) {}
+
+    private void onWorldBorderChange(WorldBorder border, Packet<?> packet) {
+        if (!updatingWorldBorder && border.world != null && border.world.getWorldBorder() == border) {
+            MultiPaper.broadcastPacketToExternalServers(border.world.getWorld().getName(), new SendUpdatePacket(border.world.uuid, packet));
+
+            // Save the level.dat
+            border.world.saveIncrementally(true);
+        }
+    }
+
+    public static void handle(UUID world, Packet<?> packet) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+
+        updatingWorldBorder = true;
+
+        if (packet instanceof ClientboundSetBorderSizePacket setBorderSizePacket) {
+            level.getWorldBorder().setSize(setBorderSizePacket.getSize());
+        } else if (packet instanceof ClientboundSetBorderLerpSizePacket setBorderLerpSizePacket) {
+            level.getWorldBorder().lerpSizeBetween(setBorderLerpSizePacket.getOldSize(), setBorderLerpSizePacket.getNewSize(), setBorderLerpSizePacket.getLerpTime());
+        } else if (packet instanceof ClientboundSetBorderCenterPacket setBorderCenterPacket) {
+            level.getWorldBorder().setCenter(setBorderCenterPacket.getNewCenterX(), setBorderCenterPacket.getNewCenterZ());
+        } else if (packet instanceof ClientboundSetBorderWarningDelayPacket setBorderWarningDelayPacket) {
+            level.getWorldBorder().setWarningTime(setBorderWarningDelayPacket.getWarningDelay());
+        } else if (packet instanceof ClientboundSetBorderWarningDistancePacket setBorderWarningDistancePacket) {
+            level.getWorldBorder().setWarningBlocks(setBorderWarningDistancePacket.getWarningBlocks());
+        }
+
+        updatingWorldBorder = false;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketHandler.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketHandler.java
index 4b5bb154c26b6a1c95d013b571c1d0f7867f52d2..e4ecd29f6fe5c7d10613b9db6c7b7563d21ea02e 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketHandler.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketHandler.java
@@ -19,6 +19,7 @@ public class ExternalServerPacketHandler extends SimpleChannelInboundHandler<Ext
 
     @Override
     protected void channelRead0(ChannelHandlerContext ctx, ExternalServerPacket msg) {
+        connection.lastPacketReceived = System.currentTimeMillis();
         msg.handle(connection);
     }
 
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
index 361232ab565973d262cfb6ecc54fd823e28d799e..191294b08434bd4ea0a7ea29d040b782125eb7e9 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -20,6 +20,10 @@ public class ExternalServerPacketSerializer {
         addPacket(PlayerRespawnPacket.class, PlayerRespawnPacket::new);
         addPacket(PlayerChangeDimensionPacket.class, PlayerChangeDimensionPacket::new);
         addPacket(SendPacketPacket.class, SendPacketPacket::new);
+        addPacket(SendUpdatePacket.class, SendUpdatePacket::new);
+        addPacket(RequestChunkPacket.class, RequestChunkPacket::new);
+        addPacket(SendChunkPacket.class, SendChunkPacket::new);
+        addPacket(SendTickListPacket.class, SendTickListPacket::new);
     }
 
     private static void addPacket(Class<? extends ExternalServerPacket> clazz, Function<FriendlyByteBuf, ExternalServerPacket> deserializer) {
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..4bfe8626ccfc5de2918a3b3416c884e74b26cba3
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java
@@ -0,0 +1,146 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ThreadedLevelLightEngine;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServer;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.util.ConcurrentModificationException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+public class RequestChunkPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(RequestChunkPacket.class.getSimpleName());
+    public static ExternalServer blocker = null;
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+
+    public RequestChunkPacket(String world, int cx, int cz) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+    }
+
+    public RequestChunkPacket(FriendlyByteBuf in) {
+        world = in.readUtf();
+        cx = in.readInt();
+        cz = in.readInt();
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        World bukkitWorld = Bukkit.getWorld(world);
+
+        if (!(bukkitWorld instanceof CraftWorld craftWorld)) {
+            LOGGER.warn(connection.externalServer.getName() + " is requesting chunk " + world + "," + cx + "," + cz + " but we don't have the world " + world + " loaded.");
+            connection.send(new SendChunkPacket(world, cx, cz, null));
+            return;
+        }
+
+        ServerLevel level = craftWorld.getHandle();
+        NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(world, cx, cz);
+
+        if (newChunkHolder == null) {
+            LOGGER.warn(connection.externalServer.getName() + " is requesting chunk " + world + "," + cx + "," + cz + " but we aren't trying to load it.");
+            connection.send(new SendChunkPacket(world, cx, cz, null));
+            return;
+        }
+
+        CompletableFuture<ChunkAccess> future = newChunkHolder.onCurrentChunkLoaded();
+
+        CompletableFuture<ChunkAccess> futureToWaitOn = future;
+        if (blocker == connection.externalServer) {
+            ChunkAccess access = newChunkHolder.getCurrentChunk();
+            if (access != null) {
+                futureToWaitOn = CompletableFuture.completedFuture(newChunkHolder.getCurrentChunk());
+            } else {
+                connection.send(new SendChunkPacket(world, cx, cz, null));
+                return;
+            }
+        }
+
+        futureToWaitOn.thenAccept(chunk -> {
+            if (future != newChunkHolder.onCurrentChunkLoaded()) {
+                // The future has been updated, try again
+                handle(connection);
+                return;
+            }
+
+            if (chunk == null) {
+                LOGGER.warn(connection.externalServer.getName() + " is requesting chunk " + world + "," + cx + "," + cz + " but we don't have it loaded.");
+                connection.send(new SendChunkPacket(world, cx, cz, null));
+                return;
+            }
+
+            CompletableFuture<Void> lightFuture = ((ThreadedLevelLightEngine) level.getLightEngine()).theLightEngine.lightQueue.getChunkFuture(newChunkHolder.vanillaChunkHolder.getPos());
+
+            if (!lightFuture.isDone()) {
+                lightFuture.thenRunAsync(() -> handle(connection));
+                return;
+            }
+
+            try {
+                ListTag entitiesToLoad = null;
+                ListTag blockEntitiesToLoad = null;
+
+                ChunkAccess fullChunk = chunk instanceof ImposterProtoChunk imposterProtoChunk ? imposterProtoChunk.getWrapped() : chunk;
+
+                if (fullChunk instanceof LevelChunk levelChunk) {
+                    // Cache these tags in case they get deleted while we serialize the chunk (multi-threaded fun!)
+                    entitiesToLoad = levelChunk.entitiesToLoad;
+                    blockEntitiesToLoad = levelChunk.blockEntitiesToLoad;
+                }
+
+                CompoundTag tag = ChunkSerializer.write(level, chunk);
+
+                if (entitiesToLoad != null) {
+                    tag.put("entities", entitiesToLoad);
+                }
+                if (blockEntitiesToLoad != null) {
+                    tag.put("block_entities", blockEntitiesToLoad);
+                }
+
+                connection.send(new SendChunkPacket(world, cx, cz, tag));
+            } catch (ConcurrentModificationException e) {
+                LOGGER.warn("Got ConcurrentModificationException while sending chunk, sending it in main thread instead");
+                MultiPaper.runSync(() -> handle(connection));
+            }
+        })
+        // Timeout instantly if this server is blocking our chunk loading, as this is probably also blocking their chunk loading
+        .orTimeout(15, TimeUnit.SECONDS).exceptionally(throwable -> {
+            if (throwable instanceof TimeoutException) {
+                LOGGER.warn("Timed out while sending chunk " + world + "," + cx + "," + cz);
+            } else {
+                LOGGER.warn("Error while sending chunk " + world + "," + cx + "," + cz, throwable);
+            }
+
+            connection.send(new SendChunkPacket(world, cx, cz, null));
+            return null;
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..8ed4aebd2a08e9dbcb1e5d17fe30eadb87428a74
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java
@@ -0,0 +1,122 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ChunkKey;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.ByteArrayInputStream;
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.util.function.Consumer;
+import java.util.zip.InflaterInputStream;
+
+public class SendChunkPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendChunkPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+    private final byte[] data;
+
+    public SendChunkPacket(String world, int cx, int cz, CompoundTag tag) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+
+        try {
+            if (tag == null) {
+                data = new byte[0];
+            } else {
+                data = MultiPaper.nbtToBytes(tag);
+            }
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public SendChunkPacket(FriendlyByteBuf in) {
+        world = in.readUtf();
+        cx = in.readInt();
+        cz = in.readInt();
+        data = in.readByteArray();
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeByteArray(data);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        try {
+            Consumer<DataInputStream> callback = connection.chunkCallbacks.remove(new ChunkKey(world, cx, cz));
+            if (callback != null) {
+                if (data.length == 0) {
+                    LOGGER.warn(connection.externalServer.getName() + " sent us an empty chunk for " + world + "," + cx + "," + cz + ", force loading it from disk");
+                    MultiPaper.forceReadChunk(world, "region", cx, cz).thenAccept(data2 -> callback.accept(data2.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data2)))));
+                } else {
+                    callback.accept(new DataInputStream(new ByteArrayInputStream(data)));
+                }
+            } else {
+                if (data.length == 0) {
+                    return;
+                }
+
+                CompoundTag tag = MultiPaper.nbtFromBytes(data);
+                CraftWorld craftWorld = ((CraftWorld) Bukkit.getWorld(world));
+                ServerLevel level = craftWorld != null ? craftWorld.getHandle() : null;
+                NewChunkHolder holder = MultiPaper.getChunkHolder(world, cx, cz);
+                if (level == null) {
+                    LOGGER.warn("Received chunk data " + world + "," + cx + "," + cz + " but we don't have world loaded.");
+                } else if (holder == null) {
+                    LOGGER.warn("Received chunk data " + world + "," + cx + "," + cz + " but no chunk is loaded here");
+                } else if (holder.getCurrentChunk() instanceof LevelChunk) {
+                    LOGGER.warn("Received chunk data " + world + "," + cx + "," + cz + " (" + tag.getString("Status") + "), but it is a level chunk (" + holder.getCurrentGenStatus() + ")");
+                } else {
+                    LOGGER.warn("Received chunk data " + world + "," + cx + "," + cz + " (" + tag.getString("Status") + "), but we have a " + holder.getCurrentGenStatus() + " chunk, forcing reload from disk.");
+                    forceChunkUnsafeUnload(world, cx, cz);
+                }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private ChunkAccess loadChunk(ServerLevel level, ChunkPos pos, CompoundTag tag) {
+        ChunkSerializer.InProgressChunkHolder newChunk = ChunkSerializer.loadChunk(level, level.getPoiManager(), pos, tag, true);
+        return newChunk.protoChunk instanceof ImposterProtoChunk imposterProtoChunk ? imposterProtoChunk.getWrapped() : newChunk.protoChunk;
+    }
+
+    public static void forceChunkUnsafeUnload(String world, int cx, int cz) {
+        MultiPaper.runSync(() -> {
+            ChunkPos pos = new ChunkPos(cx, cz);
+            CraftWorld craftWorld = ((CraftWorld) Bukkit.getWorld(world));
+            if (craftWorld != null) {
+                ServerLevel level = craftWorld.getHandle();
+                NewChunkHolder holder = level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(pos.longKey);
+
+                if (holder != null) {
+                    level.chunkTaskScheduler.chunkHolderManager.unloadChunkNowNoSave(holder);
+                }
+            }
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..801d03669f9056ca9cd3dc2c617521c29a6854be
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java
@@ -0,0 +1,89 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import net.minecraft.world.ticks.LevelChunkTicks;
+import net.minecraft.world.ticks.ProtoChunkTicks;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.IOException;
+
+public class SendTickListPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendTickListPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+    private final CompoundTag tag;
+
+    public SendTickListPacket(LevelChunk chunk) {
+        this.world = chunk.level.convertable.getLevelId();
+        this.cx = chunk.locX;
+        this.cz = chunk.locZ;
+
+        tag = new CompoundTag();
+        tag.put("block_ticks", chunk.blockTicks.save(chunk.level.getLevelData().getGameTime(), (block) -> BuiltInRegistries.BLOCK.getKey(block).toString()));
+        tag.put("fluid_ticks", chunk.fluidTicks.save(chunk.level.getLevelData().getGameTime(), (fluidtype) -> BuiltInRegistries.FLUID.getKey(fluidtype).toString()));
+    }
+
+    public SendTickListPacket(FriendlyByteBuf in) {
+        this.world = in.readUtf();
+        this.cx = in.readInt();
+        this.cz = in.readInt();
+
+        byte[] data = in.readByteArray();
+        try {
+            tag = MultiPaper.nbtFromBytes(data);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+
+        try {
+            byte[] data = MultiPaper.nbtToBytes(tag);
+
+            out.writeByteArray(data);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+            ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+            if (chunk instanceof LevelChunk levelChunk) {
+                levelChunk.unregisterTickContainerFromLevel(level);
+                levelChunk.blockTicks = LevelChunkTicks.load(tag.getList("block_ticks", Tag.TAG_COMPOUND), s -> BuiltInRegistries.BLOCK.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+                levelChunk.fluidTicks = LevelChunkTicks.load(tag.getList("fluid_ticks", Tag.TAG_COMPOUND), s -> BuiltInRegistries.FLUID.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+                levelChunk.unpackTicks(level.getLevelData().getGameTime());
+                if (levelChunk.loaded) levelChunk.registerTickContainerInLevel(level);
+            } else if (chunk instanceof ProtoChunk protoChunk) {
+                protoChunk.blockTicks = ProtoChunkTicks.load(tag.getList("block_ticks", Tag.TAG_COMPOUND), s -> BuiltInRegistries.BLOCK.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+                protoChunk.fluidTicks = ProtoChunkTicks.load(tag.getList("fluid_ticks", Tag.TAG_COMPOUND), s -> BuiltInRegistries.FLUID.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+            } else {
+                LOGGER.warn("Received tick lists for an unloaded chunk " + world + "," + cx + "," + cz);
+            }
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..c9ad59beb1115af9b058b3a03e41705f74df2cba
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
@@ -0,0 +1,65 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.*;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
+import puregero.multipaper.MultiPaperWorldBorderHandler;
+
+import java.util.UUID;
+
+public class SendUpdatePacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendUpdatePacket.class.getSimpleName());
+
+    private final UUID world;
+    private final Packet<?> packet;
+
+    public SendUpdatePacket(UUID world, Packet<?> packet) {
+        this.world = world;
+        this.packet = packet;
+    }
+
+    public SendUpdatePacket(FriendlyByteBuf in) {
+        world = in.readUUID();
+
+        byte[] bytes = in.readByteArray();
+        ByteBuf buf = Unpooled.wrappedBuffer(bytes);
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        friendlyByteBuf.maxNbtSize = Long.MAX_VALUE;
+        int packetId = friendlyByteBuf.readVarInt();
+        packet = ConnectionProtocol.PLAY.createPacket(PacketFlow.CLIENTBOUND, packetId, friendlyByteBuf);
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUUID(world);
+
+        ConnectionProtocol protocol = ConnectionProtocol.getProtocolForPacket(packet);
+        Integer id = protocol.getPacketId(PacketFlow.CLIENTBOUND, packet);
+        ByteBuf buf = Unpooled.buffer();
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        friendlyByteBuf.writeVarInt(id);
+        packet.write(friendlyByteBuf);
+        out.writeByteArray(buf.array());
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        if (packet instanceof ClientboundBlockUpdatePacket || packet instanceof ClientboundSectionBlocksUpdatePacket || packet instanceof ClientboundLightUpdatePacket || packet instanceof ClientboundBlockEntityDataPacket) {
+            MultiPaper.runSync(() -> MultiPaperChunkHandler.handleBlockUpdate(world, packet, 0));
+        } else if (packet instanceof ClientboundSetBorderSizePacket || packet instanceof ClientboundSetBorderLerpSizePacket || packet instanceof ClientboundSetBorderCenterPacket || packet instanceof ClientboundSetBorderWarningDelayPacket || packet instanceof ClientboundSetBorderWarningDistancePacket) {
+            MultiPaper.runSync(() -> MultiPaperWorldBorderHandler.handle(world, packet));
+        } else {
+            LOGGER.warn("Unhandled update packet of type " + packet.getClass().getSimpleName());
+        }
+    }
+}
