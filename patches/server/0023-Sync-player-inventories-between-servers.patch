From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Thu, 18 Nov 2021 00:00:34 +1000
Subject: [PATCH] Sync player inventories between servers


diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 8fb1aaeefaff1894e60c1baf7eba7f5d7de6ae1c..2742916f9e669a735c72ff492fdbc4425c519296 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -187,8 +187,7 @@ import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.event.player.PlayerToggleSneakEvent;
 import org.bukkit.inventory.MainHand;
-import puregero.multipaper.ExternalServerConnection;
-import puregero.multipaper.MultiPaper;
+import puregero.multipaper.*;
 import puregero.multipaper.externalserverprotocol.PlayerChangeDimensionPacket;
 import puregero.multipaper.externalserverprotocol.PlayerChangeGamemodePacket;
 import puregero.multipaper.externalserverprotocol.PlayerCreatePacket;
@@ -257,6 +256,7 @@ public class ServerPlayer extends Player {
     @Nullable
     private RemoteChatSession chatSession;
     private int containerCounter;
+    @Nullable public ExternalServer openContainer; // MultiPaper
     public boolean wonGame;
     public int containerUpdateDelay; // Paper // MultiPaper - make public
     public long loginTime; // Paper
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 482f459fa0cf3c8a400e94b1c02bf6f2e038d8ca..1888be4cc65135c1cfce7b207eefc0ca7540c3a3 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -244,6 +244,8 @@ import org.bukkit.inventory.SmithingInventory;
 import puregero.multipaper.ExternalPlayer;
 import puregero.multipaper.MultiPaper;
 import puregero.multipaper.MultiPaperAckBlockChangesHandler;
+import puregero.multipaper.MultiPaperInventoryHandler;
+import puregero.multipaper.externalserverprotocol.PlayerActionPacket;
 import puregero.multipaper.externalserverprotocol.PlayerRemovePacket;
 // CraftBukkit end
 
@@ -735,6 +737,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     @Override
     public void handleAcceptTeleportPacket(ServerboundAcceptTeleportationPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
+        MultiPaperInventoryHandler.handleAcceptTeleport(this.player, packet); // MultiPaper
         if (packet.getId() == this.awaitingTeleport) {
             if (this.awaitingPositionFromClient == null) {
                 this.disconnect(Component.translatable("multiplayer.disconnect.invalid_player_movement"), org.bukkit.event.player.PlayerKickEvent.Cause.INVALID_PLAYER_MOVEMENT); // Paper - kick event cause
@@ -769,6 +772,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     @Override
     public void handleRecipeBookChangeSettingsPacket(ServerboundRecipeBookChangeSettingsPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
+        MultiPaperInventoryHandler.handleContainerEvent(this.player, packet); // MultiPaper
         CraftEventFactory.callRecipeBookSettingsEvent(this.player, packet.getBookType(), packet.isOpen(), packet.isFiltering()); // CraftBukkit
         this.player.getRecipeBook().setBookSetting(packet.getBookType(), packet.isOpen(), packet.isFiltering());
     }
@@ -1002,6 +1006,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     @Override
     public void handleRenameItem(ServerboundRenameItemPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
+        if (MultiPaperInventoryHandler.handleContainerEvent(this.player, packet)) return; // MultiPaper
         AbstractContainerMenu container = this.player.containerMenu;
 
         if (container instanceof AnvilMenu) {
@@ -1020,6 +1025,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     @Override
     public void handleSetBeaconPacket(ServerboundSetBeaconPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
+        if (MultiPaperInventoryHandler.handleContainerEvent(this.player, packet)) return; // MultiPaper
         AbstractContainerMenu container = this.player.containerMenu;
 
         if (container instanceof BeaconMenu) {
@@ -1137,6 +1143,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     @Override
     public void handleSelectTrade(ServerboundSelectTradePacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
+        if (MultiPaperInventoryHandler.handleContainerEvent(this.player, packet)) return;
         int i = packet.getItem();
         AbstractContainerMenu container = this.player.containerMenu;
 
@@ -1975,6 +1982,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
     @Override
     public void handleUseItemOn(ServerboundUseItemOnPacket packet) {
+        if (MultiPaperInventoryHandler.handleInteractEvent(this.player, packet)) return; // MultiPaper - send to external server if necessary
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         if (this.player.isImmobile()) return; // CraftBukkit
         if (!this.checkLimit(packet.timestamp)) return; // Spigot - check limit
@@ -2037,6 +2045,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         if (this.player.isImmobile()) return; // CraftBukkit
         if (!this.checkLimit(packet.timestamp)) return; // Spigot - check limit
+        if (MultiPaperInventoryHandler.handleUseItemEvent(this.player, packet)) return; // MultiPaper
         this.ackBlockChangesUpTo(packet.getSequence());
         ServerLevel worldserver = this.player.serverLevel();
         InteractionHand enumhand = packet.getHand();
@@ -2204,6 +2213,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
             this.player.getInventory().selected = packet.getSlot();
             this.player.resetLastActionTime();
+            if (MultiPaper.isRealPlayer(this.player)) MultiPaper.broadcastPacketToExternalServers(this.player, new PlayerActionPacket(this.player, packet)); // MultiPaper
+            else this.player.detectEquipmentUpdates(); // MultiPaper
         } else {
             ServerGamePacketListenerImpl.LOGGER.warn("{} tried to set an invalid carried item", this.player.getName().getString());
             this.disconnect("Invalid hotbar selection (Hacking?)", org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION); // CraftBukkit // Paper - kick event cause
@@ -2938,6 +2949,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     public void handleContainerClose(ServerboundContainerClosePacket packet, org.bukkit.event.inventory.InventoryCloseEvent.Reason reason) {
         // Paper end - Inventory close reason
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
+        if (MultiPaperInventoryHandler.handleContainerEvent(this.player, packet)) return; // MultiPaper
 
         if (this.player.isImmobile()) return; // CraftBukkit
         CraftEventFactory.handleInventoryCloseEvent(this.player, reason); // CraftBukkit // Paper
@@ -2948,6 +2960,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     @Override
     public void handleContainerClick(ServerboundContainerClickPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
+        if (MultiPaperInventoryHandler.handleContainerEvent(this.player, packet)) return; // MultiPaper
         if (this.player.isImmobile()) return; // CraftBukkit
         this.player.resetLastActionTime();
         if (this.player.containerMenu.containerId == packet.getContainerId() && this.player.containerMenu.stillValid(this.player)) { // CraftBukkit
@@ -3294,6 +3307,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         }
         // Paper end - auto recipe limit
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
+        if (MultiPaperInventoryHandler.handleContainerEvent(this.player, packet)) return; // MultiPaper
         this.player.resetLastActionTime();
         if (!this.player.isSpectator() && this.player.containerMenu.containerId == packet.getContainerId() && this.player.containerMenu instanceof RecipeBookMenu) {
             if (!this.player.containerMenu.stillValid(this.player)) {
@@ -3342,6 +3356,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     @Override
     public void handleContainerButtonClick(ServerboundContainerButtonClickPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
+        if (MultiPaperInventoryHandler.handleContainerEvent(this.player, packet)) return; // MultiPaper
         if (this.player.isImmobile()) return; // CraftBukkit
         this.player.resetLastActionTime();
         if (this.player.containerMenu.containerId == packet.getContainerId() && !this.player.isSpectator()) {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index f2c6b52fe7fbb05afa0074684cd195f6ae598f1f..f8d94039d204962e238513f7b998f7054377d2a5 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -90,14 +90,7 @@ import net.minecraft.world.level.Explosion;
 import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
-import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.FenceGateBlock;
-import net.minecraft.world.level.block.HoneyBlock;
-import net.minecraft.world.level.block.Mirror;
-import net.minecraft.world.level.block.RenderShape;
-import net.minecraft.world.level.block.Rotation;
-import net.minecraft.world.level.block.SoundType;
+import net.minecraft.world.level.block.*;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.border.WorldBorder;
@@ -157,6 +150,7 @@ import org.bukkit.event.entity.EntityPoseChangeEvent;
 import org.bukkit.event.entity.EntityRemoveEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.plugin.PluginManager;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public abstract class Entity implements Nameable, EntityAccess, CommandSource, ScoreHolder {
@@ -1678,7 +1672,15 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
                         }
 
                         blockposition_mutableblockposition.set(i, j, k);
-                        BlockState iblockdata = this.level().getBlockState(blockposition_mutableblockposition);
+                        // MultiPaper start - Only check for blocks on our server (or portals)
+                        // Lazy load - Load iblockdata here only if we'll use it for the check
+                        BlockState iblockdata = this instanceof ServerPlayer ? this.level().getBlockState(blockposition_mutableblockposition) : null;
+                        boolean tickOnLocalServer = iblockdata != null && (iblockdata.getBlock() instanceof NetherPortalBlock || iblockdata.getBlock() instanceof EndPortalBlock || iblockdata.getBlock() instanceof PowderSnowBlock || iblockdata.getBlock() instanceof SweetBerryBushBlock || iblockdata.getBlock() instanceof WebBlock);
+                        if (!(tickOnLocalServer && MultiPaper.isRealPlayer(this)) && MultiPaper.isChunkExternal(this.level.getChunkAt(blockposition_mutableblockposition))) continue;
+                        if (tickOnLocalServer && MultiPaper.isExternalPlayer(this)) continue;
+                        // Lazy load - Fully load iblockdata here since we passed the check and will use it now
+                        iblockdata = iblockdata != null ? iblockdata : this.level.getBlockState(blockposition_mutableblockposition);
+                        // MultiPaper end
 
                         try {
                             iblockdata.entityInside(this.level(), blockposition_mutableblockposition, this);
diff --git a/src/main/java/net/minecraft/world/entity/player/Inventory.java b/src/main/java/net/minecraft/world/entity/player/Inventory.java
index c6a925cbd35eb33b27b90bfa8344ac7515d28b76..bb0fc0e83224167e191a48ae4115b4fa84ea665b 100644
--- a/src/main/java/net/minecraft/world/entity/player/Inventory.java
+++ b/src/main/java/net/minecraft/world/entity/player/Inventory.java
@@ -30,6 +30,7 @@ import java.util.ArrayList;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.entity.HumanEntity;
+import puregero.multipaper.NonNullListFilter;
 // CraftBukkit end
 
 public class Inventory implements Container, Nameable {
@@ -41,10 +42,12 @@ public class Inventory implements Container, Nameable {
     public static final int NOT_FOUND_INDEX = -1;
     public static final int[] ALL_ARMOR_SLOTS = new int[]{0, 1, 2, 3};
     public static final int[] HELMET_SLOT_ONLY = new int[]{3};
-    public final NonNullList<ItemStack> items;
-    public final NonNullList<ItemStack> armor;
-    public final NonNullList<ItemStack> offhand;
-    public final List<NonNullList<ItemStack>> compartments;
+    // MultiPaper start - Use NonNullListFilter instead of NonNullList
+    public final NonNullListFilter<ItemStack> items;
+    public final NonNullListFilter<ItemStack> armor;
+    public final NonNullListFilter<ItemStack> offhand;
+    public final List<NonNullListFilter<ItemStack>> compartments;
+    // MultiPaper end
     public int selected;
     public final Player player;
     private int timesChanged;
@@ -98,9 +101,11 @@ public class Inventory implements Container, Nameable {
     // CraftBukkit end
 
     public Inventory(Player player) {
-        this.items = NonNullList.withSize(36, ItemStack.EMPTY);
-        this.armor = NonNullList.withSize(4, ItemStack.EMPTY);
-        this.offhand = NonNullList.withSize(1, ItemStack.EMPTY);
+        // MultiPaper start - Filter the inventory and sync it with other server
+        this.items = NonNullListFilter.withSize(36, ItemStack.EMPTY, player, "items");
+        this.armor = NonNullListFilter.withSize(4, ItemStack.EMPTY, player, "armor");
+        this.offhand = NonNullListFilter.withSize(1, ItemStack.EMPTY, player, "offhand");
+        // MultiPaper end
         this.compartments = ImmutableList.of(this.items, this.armor, this.offhand);
         this.player = player;
     }
@@ -438,6 +443,8 @@ public class Inventory implements Container, Nameable {
             }
         }
 
+        if (list != null) ((NonNullListFilter<ItemStack>) list).markDirty(slot); // MultiPaper
+
         return list != null && !((ItemStack) list.get(slot)).isEmpty() ? ContainerHelper.removeItem(list, slot, amount) : ItemStack.EMPTY;
     }
 
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index f6664447c45b1d6f3371af7bed8b1175b17f25e2..c20f33284174473cc56c5eb144da759916c97ca3 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -115,6 +115,7 @@ import org.bukkit.entity.Player;
 import org.bukkit.event.block.BlockFertilizeEvent;
 import org.bukkit.event.player.PlayerItemDamageEvent;
 import org.bukkit.event.world.StructureGrowEvent;
+import puregero.multipaper.NonNullListFilter;
 // CraftBukkit end
 
 public final class ItemStack {
@@ -176,6 +177,17 @@ public final class ItemStack {
     private AdventureModeCheck adventureBreakCheck;
     @Nullable
     private AdventureModeCheck adventurePlaceCheck;
+    // MultiPaper start
+    public boolean dirty = true;
+    static { EMPTY.dirty = false; }
+    @Nullable
+    public NonNullListFilter<? extends ItemStack> listeningComponent;
+    public void markDirty() {
+        if (this == EMPTY || listeningComponent == null || listeningComponent.markDirty()) {
+            dirty = true;
+        }
+    }
+    // MultiPaper end
 
     public Optional<TooltipComponent> getTooltipImage() {
         return this.getItem().getTooltipImage(this);
@@ -260,6 +272,7 @@ public final class ItemStack {
             this.setDamageValue(this.getDamageValue());
         }
 
+        markDirty(); // MultiPaper
     }
 
     private ItemStack(@Nullable Void v) {
@@ -631,6 +644,8 @@ public final class ItemStack {
 
     public void setDamageValue(int damage) {
         this.getOrCreateTag().putInt("Damage", Math.max(0, damage));
+
+        markDirty(); // MultiPaper
     }
 
     public int getMaxDamage() {
@@ -947,6 +962,7 @@ public final class ItemStack {
             this.getItem().verifyTagAfterLoad(nbt);
         }
 
+        markDirty(); // MultiPaper
     }
 
     public Component getHoverName() {
@@ -978,6 +994,8 @@ public final class ItemStack {
             nbttagcompound.remove("Name");
         }
 
+        markDirty(); // MultiPaper
+
         return this;
     }
 
@@ -995,6 +1013,8 @@ public final class ItemStack {
             this.tag = null;
         }
 
+        markDirty(); // MultiPaper
+
     }
 
     public boolean hasCustomHoverName() {
@@ -1188,6 +1208,8 @@ public final class ItemStack {
         CompoundTag nbttagcompound = this.getOrCreateTag();
 
         nbttagcompound.putInt("HideFlags", nbttagcompound.getInt("HideFlags") | tooltipSection.getMask());
+
+        markDirty(); // MultiPaper
     }
 
     public static void appendEnchantmentNames(List<Component> tooltip, ListTag enchantments) {
@@ -1237,6 +1259,8 @@ public final class ItemStack {
 
         nbttaglist.add(EnchantmentHelper.storeEnchantment(EnchantmentHelper.getEnchantmentId(enchantment), (org.purpurmc.purpur.PurpurConfig.clampEnchantLevels) ? (byte) level : (short) level)); // Purpur
         processEnchantOrder(this.tag); // Paper
+
+        markDirty(); // MultiPaper
     }
 
     public boolean isEnchanted() {
@@ -1251,6 +1275,8 @@ public final class ItemStack {
 
     public void addTagElement(String key, Tag element) {
         this.getOrCreateTag().put(key, element);
+
+        markDirty(); // MultiPaper
     }
 
     public boolean isFramed() {
@@ -1278,6 +1304,8 @@ public final class ItemStack {
     public void setRepairCost(int repairCost) {
         if (repairCost > 0) {
             this.getOrCreateTag().putInt("RepairCost", repairCost);
+
+            markDirty(); // MultiPaper
         } else {
             this.removeTagKey("RepairCost");
         }
@@ -1335,6 +1363,8 @@ public final class ItemStack {
     public void setItem(Item item) {
         this.bukkitStack = null; // Paper
         this.item = item;
+
+        markDirty(); // MultiPaper
     }
     // CraftBukkit end
 
@@ -1386,6 +1416,8 @@ public final class ItemStack {
 
     public void setCount(int count) {
         this.count = count;
+
+        markDirty(); // MultiPaper
     }
 
     public void grow(int amount) {
diff --git a/src/main/java/puregero/multipaper/ExternalPlayer.java b/src/main/java/puregero/multipaper/ExternalPlayer.java
index f7eca42db18350535739b5eee6ecd2764684617d..e7085ebe21c98fbe3948681238fffedbbb10d56f 100644
--- a/src/main/java/puregero/multipaper/ExternalPlayer.java
+++ b/src/main/java/puregero/multipaper/ExternalPlayer.java
@@ -39,7 +39,9 @@ public class ExternalPlayer extends ServerPlayer {
 
     public ExternalPlayer(ExternalServerConnection externalServerConnection, GameProfile gameProfile, String world, double x, double y, double z, float yaw, float pitch, GameType gamemode, InetSocketAddress address, CompoundTag saveData) {
         super(((CraftServer) Bukkit.getServer()).getServer(), ((CraftWorld) Bukkit.getWorld(world)).getHandle(), gameProfile);
+        MultiPaperInventoryHandler.updatingInventory = true;
         this.load(saveData);
+        MultiPaperInventoryHandler.updatingInventory = false;
         this.externalServerConnection = externalServerConnection;
         this.address = address;
         this.isRealPlayer = true;
@@ -104,4 +106,9 @@ public class ExternalPlayer extends ServerPlayer {
     public boolean broadcastToPlayer(ServerPlayer spectator) {
         return false;
     }
+
+    @Override
+    public void checkInsideBlocks() {
+        super.checkInsideBlocks();
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index 57ed0341e4f5310905e1f6eaf69df5ab60f525bd..810597b0777bba5f0ef8b09b846c503b355d93a8 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -85,6 +85,8 @@ public class MultiPaper {
                     externalPlayer.containerUpdateDelay = externalPlayer.level().paperConfig().tickRates.containerUpdate;
                 }
                 // Copied from Paper end
+
+                externalPlayer.checkInsideBlocks();
             }
         }
 
@@ -121,6 +123,8 @@ public class MultiPaper {
         });
 
         MultiPaperAckBlockChangesHandler.tick();
+
+        MultiPaperInventoryHandler.tick();
     }
 
     public static void sendTickTime(long time, double tps) {
diff --git a/src/main/java/puregero/multipaper/MultiPaperInventoryHandler.java b/src/main/java/puregero/multipaper/MultiPaperInventoryHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..18a7238cc79c06a63dcfbaeb957cc769204f7282
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperInventoryHandler.java
@@ -0,0 +1,349 @@
+package puregero.multipaper;
+
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundContainerClosePacket;
+import net.minecraft.network.protocol.game.ClientboundOpenScreenPacket;
+import net.minecraft.network.protocol.game.ClientboundPlayerPositionPacket;
+import net.minecraft.network.protocol.game.ClientboundSetCarriedItemPacket;
+import net.minecraft.network.protocol.game.ClientboundSetExperiencePacket;
+import net.minecraft.network.protocol.game.ServerGamePacketListener;
+import net.minecraft.network.protocol.game.ServerboundAcceptTeleportationPacket;
+import net.minecraft.network.protocol.game.ServerboundContainerClosePacket;
+import net.minecraft.network.protocol.game.ServerboundUseItemOnPacket;
+import net.minecraft.network.protocol.game.ServerboundUseItemPacket;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.RelativeMovement;
+import net.minecraft.world.entity.item.ItemEntity;
+import net.minecraft.world.item.BucketItem;
+import net.minecraft.world.item.EnderEyeItem;
+import net.minecraft.world.item.FishingRodItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.phys.AABB;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.externalserverprotocol.PlayerActionPacket;
+import puregero.multipaper.externalserverprotocol.PlayerInventoryUpdatePacket;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+
+public class MultiPaperInventoryHandler {
+    private static final Logger LOGGER = LogManager.getLogger(MultiPaperInventoryHandler.class.getSimpleName());
+    public static boolean updatingInventory = false;
+    private static final HashMap<UUID, ArrayList<AwaitingTeleport>> awaitingTeleports = new HashMap<>();
+    private static final Set<NonNullListFilter<? extends ItemStack>> modifiedInventories = new LinkedHashSet<>();
+
+    public static boolean handlePacketFromExternalServer(ExternalServer server, ServerPlayer player, Packet<?> packet) {
+        if (packet instanceof ClientboundOpenScreenPacket) {
+            // An external server has requested to open a window on a player
+            player.openContainer = server;
+        } else if (packet instanceof ClientboundContainerClosePacket) {
+            // An external server has requested to close the open window on a player
+            if (player.openContainer == server) {
+                player.openContainer = null;
+            }
+        } else if (packet instanceof ClientboundSetCarriedItemPacket setCarriedItemPacket) {
+            // An external server is changing the selected item in the hotbar
+            player.getInventory().selected = setCarriedItemPacket.getSlot();
+        } else if (packet instanceof ClientboundSetExperiencePacket setExperiencePacket) {
+            // An external server is changing the player's experience level
+            player.experienceLevel = setExperiencePacket.getExperienceLevel();
+            player.experienceProgress = setExperiencePacket.getExperienceProgress();
+            player.totalExperience = setExperiencePacket.getTotalExperience();
+        } else if (packet instanceof ClientboundPlayerPositionPacket playerPositionPacket) {
+            // An external server is teleporting the player
+            double x = playerPositionPacket.getRelativeArguments().contains(RelativeMovement.X) ? player.getX() : 0.0D;
+            double y = playerPositionPacket.getRelativeArguments().contains(RelativeMovement.Y) ? player.getY() : 0.0D;
+            double z = playerPositionPacket.getRelativeArguments().contains(RelativeMovement.Z) ? player.getZ() : 0.0D;
+            float yaw = playerPositionPacket.getRelativeArguments().contains(RelativeMovement.Y_ROT) ? player.getYRot() : 0.0F;
+            float pitch = playerPositionPacket.getRelativeArguments().contains(RelativeMovement.X_ROT) ? player.getXRot() : 0.0F;
+            player.connection.teleport(x + playerPositionPacket.getX(), y + playerPositionPacket.getY(), z + playerPositionPacket.getZ(), yaw + playerPositionPacket.getYRot(), pitch + playerPositionPacket.getXRot(), playerPositionPacket.getRelativeArguments());
+            server.getConnection().send(new PlayerActionPacket(player, new ServerboundAcceptTeleportationPacket(playerPositionPacket.getId())));
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Returns true if the even should be cancelled
+     */
+    public static boolean handleInteractEvent(ServerPlayer player, ServerboundUseItemOnPacket packet) {
+        NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder((ServerLevel) player.level(), packet.getHitResult().getBlockPos());
+        ItemStack item = player.getItemInHand(packet.getHand());
+        if (MultiPaper.isChunkExternal(newChunkHolder) && !(item.getItem() instanceof BucketItem)) {
+            newChunkHolder.externalOwner.getConnection().send(new PlayerActionPacket(player, packet));
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Returns true if the even should be cancelled
+     */
+    public static boolean handleUseItemEvent(ServerPlayer player, ServerboundUseItemPacket packet) {
+        NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder((ServerLevel) player.level(), player.blockPosition());
+        ItemStack item = player.getItemInHand(packet.getHand());
+        if (MultiPaper.isChunkExternal(newChunkHolder) && item.getItem() instanceof EnderEyeItem) {
+            newChunkHolder.externalOwner.getConnection().send(new PlayerActionPacket(player, packet));
+            return true;
+        } else if (MultiPaper.isRealPlayer(player) && item.getItem() instanceof FishingRodItem) {
+            MultiPaper.broadcastPacketToExternalServers(newChunkHolder.externalSubscribers, () -> new PlayerActionPacket(player, packet));
+        }
+        return false;
+    }
+
+    /**
+     * Returns true if the even should be cancelled
+     */
+    public static boolean handleContainerEvent(ServerPlayer player, Packet<ServerGamePacketListener> containerPacket) {
+        if (player.openContainer != null) {
+            player.openContainer.getConnection().send(new PlayerActionPacket(player, containerPacket));
+            if (containerPacket instanceof ServerboundContainerClosePacket) {
+                player.openContainer = null;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    public static void updateInventory(ServerPlayer player, String name, int slot, ItemStack replacingItem, ItemStack item) {
+        updatingInventory = true; // Don't let these changes mark the inventories as dirty
+        NonNullListFilter<ItemStack> component = null;
+        switch (name) {
+            case "items" -> component = player.getInventory().items;
+            case "armor" -> component = player.getInventory().armor;
+            case "offhand" -> component = player.getInventory().offhand;
+            default -> throw new IllegalArgumentException("Unknown inventory component of " + name);
+        }
+        item.dirty = false;
+        if (component != null) {
+            ItemStack lastItem = component.lastItems.get(slot);
+            ItemStack currentItem = component.get(slot);
+            if (!ItemStack.matches(lastItem, currentItem) && !MultiPaper.isRealPlayer(player)) {
+                // Our changes haven't been sent yet, send them
+                broadcastComponentChanges(player, component);
+            }
+            if (MultiPaper.isRealPlayer(player) && replacingItem != null && !ItemStack.matches(replacingItem, currentItem)) {
+                // The expected item doesn't match, a merge is required
+                item.dirty = true; component.isDirty = true; // Resend the item afterwards to sync the other servers
+                if (isSameItemSameTagIgnoringDurability(replacingItem, item)) {
+                    if (replacingItem.getCount() != item.getCount()) {
+                        int countDiff = item.getCount() - replacingItem.getCount();
+                        if (countDiff > 0) {
+                            item.setCount(countDiff);
+                            addItem(item, player);
+                        } else {
+                            LOGGER.warn(player.getScoreboardName() + ": An external server tried to remove " + countDiff + " items from " + replacingItem + ", but that item is now a " + currentItem);
+                        }
+                    } else if (replacingItem.getDamageValue() != item.getDamageValue()) {
+                        int damageDiff = item.getDamageValue() - replacingItem.getDamageValue();
+                        if (isSameItemSameTagIgnoringDurability(currentItem, item)) {
+                            currentItem.setDamageValue(currentItem.getDamageValue() + damageDiff);
+                        }
+                    } else {
+                        LOGGER.warn(player.getScoreboardName() + ": Trying to merge the same item same tags, but neither the count nor the durability is different. " + item + " and " + replacingItem + " and " + currentItem);
+                    }
+                } else {
+                    addItem(item, player);
+                    if (!replacingItem.isEmpty()) {
+                        // The item has probably duplicated, try to find one of the copies and remove it
+                        LOGGER.info(player.getScoreboardName() + ": An external server tried to replace " + replacingItem + " with a " + item + ", but that item is now a " + currentItem + ". Searching for duped items to remove...");
+                        int count = replacingItem.getCount();
+                        int removeCount = removeItem(replacingItem, player, count);
+                        if (count != removeCount) {
+                            LOGGER.info(player.getScoreboardName() + ": Removed " + (count - removeCount) + " duped items from the player's inventory");
+                        }
+                        if (removeCount > 0) {
+                            int removedEntityCount = removeItemEntity(replacingItem, player, removeCount);
+                            if (removeCount != removedEntityCount) {
+                                LOGGER.info(player.getScoreboardName() + ": Removed " + (removeCount - removedEntityCount) + " duped items from items on the ground");
+                            }
+                        }
+                    }
+                }
+            } else {
+                component.set(slot, item);
+                component.lastItems.set(slot, item.copy()); // We don't need to do this if it's our player
+            }
+        }
+        updatingInventory = false;
+    }
+
+    private static void addItem(ItemStack itemStack, ServerPlayer player) {
+        if (player.isDeadOrDying() || !player.getInventory().add(itemStack)) {
+            player.drop(itemStack, false);
+        }
+    }
+
+    private static int removeItem(ItemStack replacingItem, ServerPlayer player, int count) {
+        for (List<ItemStack> compartment : player.getInventory().compartments) {
+            for (int slot = 0; slot < compartment.size(); slot++) {
+                ItemStack item = compartment.get(slot);
+                if (ItemStack.isSameItemSameTags(item, replacingItem)) {
+                    if (item.getCount() < count) {
+                        count -= item.getCount();
+                        item.setCount(0);
+                        compartment.set(slot, ItemStack.EMPTY);
+                    } else {
+                        item.setCount(item.getCount() - count);
+                        return 0;
+                    }
+                }
+            }
+        }
+        return count;
+    }
+
+    private static int removeItemEntity(ItemStack replacingItem, ServerPlayer player, int count) {
+        for (ItemEntity entity : player.level().getEntitiesOfClass(ItemEntity.class, AABB.ofSize(player.position(), 16, 16, 16))) {
+            ItemStack item = entity.getItem();
+            if (ItemStack.isSameItemSameTags(item, replacingItem)) {
+                if (item.getCount() < count) {
+                    count -= item.getCount();
+                    item.setCount(0);
+                    entity.remove(Entity.RemovalReason.DISCARDED);
+                } else {
+                    item.setCount(item.getCount() - count);
+                    entity.remove(Entity.RemovalReason.DISCARDED);
+                    entity.spawnAtLocation(item, 0);
+                    return 0;
+                }
+            }
+        }
+        return count;
+    }
+
+    private static boolean isSameItemSameTagIgnoringDurability(ItemStack left, ItemStack right) {
+        boolean hasLeftDurability = false;
+        boolean hasRightDurability = false;
+        int leftDurability = left.getDamageValue();
+        int rightDurability = right.getDamageValue();
+        if (left.getTag() != null && left.getTag().contains("Damage")) {
+            hasLeftDurability = true;
+            left.getTag().remove("Damage");
+        }
+        if (right.getTag() != null) {
+            hasRightDurability = true;
+            right.getTag().remove("Damage");
+        }
+        boolean result = ItemStack.isSameItemSameTags(left, right);
+        if (hasLeftDurability) left.getTag().putInt("Damage", leftDurability);
+        if (hasRightDurability) right.getTag().putInt("Damage", rightDurability);
+        return result;
+    }
+
+    /**
+     * Returns true if the changes to the inventory component should be marked as dirty.
+     */
+    public static <E extends ItemStack> boolean markDirty(NonNullListFilter<E> inventoryComponent) {
+        if ( !io.papermc.paper.util.TickThread.isTickThread() ) {
+            LOGGER.warn("Asynchronous inventory modification. This is unsafe and will eventually cause an issue.", new IllegalStateException("Async access"));
+        }
+        if (!updatingInventory) {
+            modifiedInventories.add(inventoryComponent);
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Runs at the end of a vanilla tick. Ie any changes to the inventory made in the tick will instantly be updated
+     * to other servers without a tick delay.
+     */
+    public static void tick() {
+        for (NonNullListFilter<? extends ItemStack> inventoryComponent : modifiedInventories) {
+            if (inventoryComponent.player instanceof ServerPlayer player) {
+                broadcastComponentChanges(player, inventoryComponent);
+            }
+        }
+        modifiedInventories.clear();
+    }
+
+    public static void broadcastComponentChanges(ServerPlayer player, NonNullListFilter<? extends ItemStack> inventoryComponent) {
+        if (!player.didPlayerJoinEvent) {
+            // Don't update the inventory until they fully join
+            return;
+        }
+        if (inventoryComponent.isDirty) {
+            inventoryComponent.isDirty = false;
+            ListTag items = new ListTag();
+            for (int i = 0; i < inventoryComponent.size(); i++) {
+                if (inventoryComponent.dirty[i] || inventoryComponent.get(i).dirty) {
+                    CompoundTag item = new CompoundTag();
+                    item.putInt("Slot", i);
+                    inventoryComponent.get(i).save(item);
+                    items.add(item);
+                    if (!MultiPaper.isRealPlayer(player)) {
+                        CompoundTag replacingItem = new CompoundTag();
+                        inventoryComponent.lastItems.get(i).save(replacingItem);
+                        item.put("Replacing", replacingItem);
+                    }
+                    inventoryComponent.dirty[i] = false;
+                    inventoryComponent.get(i).dirty = false;
+                    inventoryComponent.lastItems.set(i, inventoryComponent.get(i).copy());
+                }
+            }
+            if (!items.isEmpty()) {
+                CompoundTag itemsRoot = new CompoundTag();
+                itemsRoot.put("items", items);
+                MultiPaper.broadcastPacketToExternalServers(player, new PlayerInventoryUpdatePacket(player, inventoryComponent.name, itemsRoot));
+                player.detectEquipmentUpdates();
+            }
+        }
+    }
+
+    public static void sendFullInventoryUpdate(ServerPlayer player, ExternalServerConnection... connections) {
+        for (NonNullListFilter<? extends ItemStack> inventoryComponent : new NonNullListFilter[] {
+                player.getInventory().items,
+                player.getInventory().armor,
+                player.getInventory().offhand,
+        }) {
+            ListTag items = new ListTag();
+            for (int i = 0; i < inventoryComponent.size(); i++) {
+                CompoundTag item = new CompoundTag();
+                item.putInt("Slot", i);
+                inventoryComponent.get(i).save(item);
+                items.add(item);
+            }
+            CompoundTag itemsRoot = new CompoundTag();
+            itemsRoot.put("items", items);
+            for (ExternalServerConnection connection : connections) {
+                connection.send(new PlayerInventoryUpdatePacket((ServerPlayer) inventoryComponent.player, inventoryComponent.name, itemsRoot));
+            }
+        }
+    }
+
+    public static void handleAcceptTeleport(ServerPlayer player, ServerboundAcceptTeleportationPacket packet) {
+        ArrayList<AwaitingTeleport> accepts = awaitingTeleports.get(player.getUUID());
+        if (accepts != null) {
+            accepts.removeIf(accept -> {
+                if (accept.id == packet.getId()) {
+                    accept.externalServer.getConnection().send(new PlayerActionPacket(player, packet));
+                    return true;
+                } else {
+                    return false;
+                }
+            });
+            if (accepts.isEmpty()) {
+                awaitingTeleports.remove(player.getUUID());
+            }
+        }
+    }
+
+    private static class AwaitingTeleport {
+        private final ExternalServer externalServer;
+        private final int id;
+        private AwaitingTeleport(ExternalServer externalServer, int id) {
+            this.externalServer = externalServer;
+            this.id = id;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/puregero/multipaper/NonNullListFilter.java b/src/main/java/puregero/multipaper/NonNullListFilter.java
new file mode 100644
index 0000000000000000000000000000000000000000..4198c5561f0b1ba92d54d7cee66131bdbb464236
--- /dev/null
+++ b/src/main/java/puregero/multipaper/NonNullListFilter.java
@@ -0,0 +1,73 @@
+package puregero.multipaper;
+
+import net.minecraft.core.NonNullList;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.ItemStack;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.Nullable;
+import java.util.Arrays;
+import java.util.List;
+
+public class NonNullListFilter<E extends ItemStack> extends NonNullList<E> {
+    public NonNullList<ItemStack> lastItems;
+    public final boolean[] dirty;
+    public final Player player;
+    public final String name;
+    public boolean isDirty;
+
+    protected NonNullListFilter(List<E> delegate, @Nullable E initialElement, Player player, String name) {
+        super(delegate, initialElement);
+        this.lastItems = NonNullList.withSize(delegate.size(), initialElement);
+        this.dirty = new boolean[delegate.size()];
+        this.player = player;
+        this.name = name;
+    }
+
+    public static <E extends ItemStack> NonNullListFilter<E> withSize(int size, E defaultValue, Player player, String name) {
+        Validate.notNull(defaultValue);
+        ItemStack[] objects = new ItemStack[size];
+        Arrays.fill(objects, defaultValue);
+        return new NonNullListFilter<E>(Arrays.asList((E[])objects), defaultValue, player, name);
+    }
+
+    public boolean markDirty() {
+        if (MultiPaperInventoryHandler.markDirty(this)) {
+            isDirty = true;
+            return true;
+        }
+        return false;
+    }
+
+    public boolean markDirty(int i) {
+        if (markDirty()) {
+            dirty[i] = true;
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public E set(int i, E object) {
+        object.listeningComponent = this;
+        markDirty(i);
+        return super.set(i, object);
+    }
+
+    @Override
+    public void add(int i, E object) {
+        throw new UnsupportedOperationException("Assumption - you can't add to a fixed sized list");
+    }
+
+    @Override
+    public E remove(int i) {
+        throw new UnsupportedOperationException("Assumption - you can't remove from a fixed sized list");
+    }
+
+    @Override
+    public void clear() {
+        if (markDirty(0)) {
+            Arrays.fill(dirty, true);
+        }
+        super.clear();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
index 6159ec1952424b652919bffc5c6e01a025f7185c..02052873895fda0c4dae745680f0c7fe7012e235 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -32,6 +32,8 @@ public class ExternalServerPacketSerializer {
         addPacket(DeopPlayerPacket.class, DeopPlayerPacket::new);
         addPacket(WhiteListPlayerPacket.class, WhiteListPlayerPacket::new);
         addPacket(RemoveWhiteListedPlayerPacket.class, RemoveWhiteListedPlayerPacket::new);
+        addPacket(PlayerActionPacket.class, PlayerActionPacket::new);
+        addPacket(PlayerInventoryUpdatePacket.class, PlayerInventoryUpdatePacket::new);
     }
 
     private static void addPacket(Class<? extends ExternalServerPacket> clazz, Function<FriendlyByteBuf, ExternalServerPacket> deserializer) {
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/PlayerActionPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerActionPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..7564da61c6bcdbb51c3be4d95949f1c4138cb550
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerActionPacket.java
@@ -0,0 +1,56 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ServerGamePacketListener;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.ExternalServerConnection;
+import java.util.UUID;
+
+public class PlayerActionPacket extends ExternalServerPacket {
+    private static final Logger LOGGER = LogManager.getLogger(PlayerActionPacket.class.getSimpleName());
+    private final UUID uuid;
+    private final Packet<ServerGamePacketListener> action;
+
+    public PlayerActionPacket(ServerPlayer player, Packet<ServerGamePacketListener> action) {
+        this.uuid = player.getUUID();
+        this.action = action;
+    }
+
+    public PlayerActionPacket(FriendlyByteBuf in) {
+        uuid = in.readUUID();
+        ByteBuf buf = Unpooled.wrappedBuffer(in.readByteArray());
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        int packetId = friendlyByteBuf.readVarInt();
+        action = (Packet<ServerGamePacketListener>) ConnectionProtocol.PLAY.createPacket(PacketFlow.SERVERBOUND, packetId, friendlyByteBuf);
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUUID(uuid);
+        ConnectionProtocol protocol = ConnectionProtocol.getProtocolForPacket(action);
+        Integer id = protocol.getPacketId(PacketFlow.SERVERBOUND, action);
+        ByteBuf buf = Unpooled.buffer();
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        friendlyByteBuf.writeVarInt(id);
+        action.write(friendlyByteBuf);
+        out.writeByteArray(buf.array());
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        ServerPlayer player = MinecraftServer.getServer().getPlayerList().getPlayer(uuid);
+        if (player == null) {
+            LOGGER.warn("Tried to run an action on a non-existent player with uuid " + uuid);
+            return;
+        }
+        player.server.execute(() -> action.handle(player.connection));
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/PlayerCreatePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerCreatePacket.java
index 6b6149102a3d6ecd0b6898d1ad149e8d742a86a1..2b0edb78ba68aa5d43b9832dddffffeb477a6f9f 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/PlayerCreatePacket.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerCreatePacket.java
@@ -3,6 +3,7 @@ package puregero.multipaper.externalserverprotocol;
 import com.mojang.authlib.GameProfile;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.game.ServerboundSetCarriedItemPacket;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.level.GameType;
@@ -12,6 +13,7 @@ import org.bukkit.event.player.PlayerKickEvent;
 import puregero.multipaper.ExternalPlayer;
 import puregero.multipaper.ExternalServerConnection;
 import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperInventoryHandler;
 
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -120,5 +122,6 @@ public class PlayerCreatePacket extends ExternalServerPacket {
         }
 
         send(new PlayerCreatePacket(player, player.saveWithoutId(new CompoundTag())), connections);
+        send(new PlayerActionPacket(player, new ServerboundSetCarriedItemPacket(player.getInventory().selected)), connections);
     }
 }
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/PlayerInventoryUpdatePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerInventoryUpdatePacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..1ce8c16819823c0c78a10a39934d896441dfed82
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerInventoryUpdatePacket.java
@@ -0,0 +1,72 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.ItemStack;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperInventoryHandler;
+import java.io.IOException;
+import java.util.UUID;
+
+public class PlayerInventoryUpdatePacket extends ExternalServerPacket {
+    private static final Logger LOGGER = LogManager.getLogger(PlayerInventoryUpdatePacket.class.getSimpleName());
+    private final UUID uuid;
+    private final String component;
+    private final CompoundTag tag;
+
+    public PlayerInventoryUpdatePacket(ServerPlayer player, String component, CompoundTag tag) {
+        this.uuid = player.getUUID();
+        this.component = component;
+        this.tag = tag;
+    }
+
+    public PlayerInventoryUpdatePacket(FriendlyByteBuf in) {
+        uuid = in.readUUID();
+        component = in.readUtf();
+        try {
+            tag = MultiPaper.nbtFromBytes(in.readByteArray());
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUUID(uuid);
+        out.writeUtf(component);
+        try {
+            out.writeByteArray(MultiPaper.nbtToBytes(tag));
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            ServerPlayer player = MinecraftServer.getServer().getPlayerList().getPlayer(uuid);
+            if (player == null) {
+                LOGGER.warn("Tried to update the inventory of a non-existent player uuid " + uuid);
+                return;
+            }
+            ListTag items = tag.getList("items", Tag.TAG_COMPOUND);
+            items.forEach(i -> {
+                CompoundTag item = (CompoundTag) i;
+                ItemStack itemStack = ItemStack.of(item);
+                ItemStack replacingItem = null;
+                if (item.contains("Replacing")) {
+                    replacingItem = ItemStack.of(item.getCompound("Replacing"));
+                }
+                MultiPaperInventoryHandler.updateInventory(player, component, item.getInt("Slot"), replacingItem, itemStack);
+            });
+            player.detectEquipmentUpdates();
+        });
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendPacketPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendPacketPacket.java
index 67fa85df260e2350824ef5f718cd4f89703e44c8..80478852fb8998698d3bb26a2ba20119755ea4dc 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/SendPacketPacket.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendPacketPacket.java
@@ -6,11 +6,14 @@ import net.minecraft.network.ConnectionProtocol;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ClientboundPlayerPositionPacket;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerPlayer;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperInventoryHandler;
 
 import java.util.List;
 import java.util.UUID;
@@ -67,7 +70,11 @@ public class SendPacketPacket extends ExternalServerPacket {
 
     @Override
     public void handle(ExternalServerConnection connection) {
-        doHandle(connection);
+        if (packet instanceof ClientboundPlayerPositionPacket) {
+            MultiPaper.runSync(() -> doHandle(connection));
+        } else {
+            doHandle(connection);
+        }
     }
 
     public void doHandle(ExternalServerConnection connection) {
@@ -79,6 +86,10 @@ public class SendPacketPacket extends ExternalServerPacket {
                 continue;
             }
 
+            if (MultiPaperInventoryHandler.handlePacketFromExternalServer(connection.externalServer, player, packet)) {
+                continue;
+            }
+
             player.connection.send(packet);
         }
     }
