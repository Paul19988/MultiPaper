From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sun, 21 Nov 2021 22:41:15 +1000
Subject: [PATCH] Sync entities


diff --git a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
index 15ee41452992714108efe53b708b5a4e1da7c1ff..6a74599f669fa19ca5fe920d66ab84558808a764 100644
--- a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
+++ b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
@@ -76,6 +76,24 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         return visibility.isAccessible() ? entity : null;
     }
 
+    // MultiPaper start
+    @Nullable
+    public Visibility getEntityStatusByUUID(UUID uuid) {
+        Entity entity;
+        this.entityByLock.readLock();
+        try {
+             entity = (this.entityByUUID.get(uuid));
+        } finally {
+            this.entityByLock.tryUnlockRead();
+        }
+        if (entity != null) {
+            return getEntityStatus(entity);
+        } else {
+            return null;
+        }
+    }
+    // MultiPaper stop
+
     @Nullable
     @Override
     public Entity get(final int id) {
@@ -412,10 +430,12 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         try {
             if (this.entityById.containsKey(entity.getId())) {
                 LOGGER.warn("Entity id already exists: " + entity.getId() + ", mapped to " + this.entityById.get(entity.getId()) + ", can't add " + entity);
+                // new Exception().printStackTrace(); // MultiPaper - commented debug by MultiPaper
                 return false;
             }
             if (this.entityByUUID.containsKey(entity.getUUID())) {
                 LOGGER.warn("Entity uuid already exists: " + entity.getUUID() + ", mapped to " + this.entityByUUID.get(entity.getUUID()) + ", can't add " + entity);
+                // new Exception().printStackTrace(); // MultiPaper - commented debug by MultiPaper
                 return false;
             }
             this.entityById.put(entity.getId(), entity);
@@ -450,6 +470,21 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         return slices == null || !slices.isPreventingStatusUpdates();
     }
 
+    // MultiPaper start - force removal
+    public void forceRemove(UUID uuid) {
+        Entity entity;
+        this.entityByLock.readLock();
+        try {
+            entity = this.entityByUUID.get(uuid);
+        } finally {
+            this.entityByLock.tryUnlockRead();
+        }
+        if (entity != null) {
+            entity.forceRemove();
+        }
+    }
+    // MultiPaper end
+
     private void removeEntity(final Entity entity) {
         final int sectionX = entity.sectionX;
         final int sectionY = entity.sectionY;
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
index 1b2f876bbfcfe17767ad64e9b5fbfcccd2d101fe..ac2b8a48dd9244b87c2fd9eede54d883fbab2118 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
@@ -39,6 +39,7 @@ import org.slf4j.Logger;
 import puregero.multipaper.ExternalServer;
 import puregero.multipaper.MultiPaper;
 import puregero.multipaper.MultiPaperChunkHandler;
+import puregero.multipaper.MultiPaperEntitiesHandler;
 import puregero.multipaper.mastermessagingprotocol.messages.masterbound.SubscribeChunkMessage;
 
 import javax.annotation.Nullable;
@@ -76,6 +77,7 @@ public final class NewChunkHolder {
     @Nullable public ExternalServer externalOwner; // MultiPaper - Chunk owner
     public Set<ExternalServer> externalSubscribers = ConcurrentHashMap.newKeySet(); // MultiPaper - Chunk subscribers
     public boolean hasExternalLockRequest = false; // MultiPaper - Have we sent a request to lock this chunk?
+    public Set<ExternalServer> externalEntitiesSubscribers = ConcurrentHashMap.newKeySet(); // MultiPaper - Entities subscribers
 
     // load/unload state
 
@@ -167,6 +169,7 @@ public final class NewChunkHolder {
             if (result != null) {
                 this.entityDataLoadTaskWaiters = null;
                 this.pendingEntityChunk = result.left() == null ? EMPTY_ENTITY_CHUNK : result.left();
+                MultiPaper.runSync(() -> world.chunkTaskScheduler.chunkHolderManager.getOrCreateEntityChunk(chunkX, chunkZ, false)); // MultiPaper - we can't leave entities cached in nbt. We need all entities accessible in case another server updates the entities in the chunk
                 if (result.right() != null) {
                     LOGGER.error("Unhandled entity data load exception, data data will be lost: ", result.right());
                 }
@@ -896,6 +899,7 @@ public final class NewChunkHolder {
             // we need to delay the callback until after determining transience, otherwise a potential loader could
             // set entityChunk before we do
             this.entityDataUnload.completable().complete(lastEntityUnload);
+            MultiPaperEntitiesHandler.onEntitiesUnload(this); // MultiPaper
         }
 
         // unload poi data
@@ -1975,6 +1979,7 @@ public final class NewChunkHolder {
                 return false;
             }
 
+            MultiPaperEntitiesHandler.willWriteEntities(this); // MultiPaper
             RegionFileIOThread.scheduleSave(this.world, this.chunkX, this.chunkZ, save, RegionFileIOThread.RegionFileType.ENTITY_DATA);
             this.lastEntitySaveNull = save == null;
             if (unloading) {
diff --git a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
index c78cbec447032de9fe69748591bef6be300160ed..e8bb247f1c79b10e7574cdb4749b3a99016559b7 100644
--- a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
+++ b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
@@ -9,6 +9,7 @@ import net.minecraft.nbt.CompoundTag;
 import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.FullChunkStatus;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
@@ -19,10 +20,14 @@ import net.minecraft.world.level.chunk.storage.EntityStorage;
 import net.minecraft.world.level.entity.Visibility;
 import net.minecraft.world.phys.AABB;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
+import puregero.multipaper.MultiPaperEntitiesHandler;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
+import java.util.Queue;
 import java.util.function.Predicate;
 import org.bukkit.event.entity.EntityRemoveEvent;
 
@@ -37,7 +42,7 @@ public final class ChunkEntitySlices {
     protected final EntityCollectionBySection allEntities;
     protected final EntityCollectionBySection hardCollidingEntities;
     protected final Reference2ObjectOpenHashMap<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
-    protected final EntityList entities = new EntityList();
+    public final EntityList entities = new EntityList(); // MultiPaper - make public
 
     public FullChunkStatus status;
 
@@ -129,6 +134,19 @@ public final class ChunkEntitySlices {
                     }
                 }
             }
+            // MultiPaper start - clear external player vehicles
+            if (MultiPaperEntitiesHandler.getControllingPassenger(entity) != null) {
+                Queue<Entity> toRemove = new LinkedList<>();
+                Entity toRemoveEntity = entity.getRootVehicle();
+                do {
+                    toRemove.addAll(toRemoveEntity.getPassengers());
+                    toRemoveEntity.forceEjectPassengers();
+                    if (!(toRemoveEntity instanceof ServerPlayer)) {
+                        toRemoveEntity.setRemoved(Entity.RemovalReason.UNLOADED_TO_CHUNK);
+                    }
+                } while ((toRemoveEntity = toRemove.poll()) != null);
+            }
+            // MultiPaper end
         }
 
         return this.entities.size() != 0;
diff --git a/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java b/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java
index 58b602e550258c1062ee940bc46538dac95d8979..313c2862fc056afa94551d278e23be59efbcdaed 100644
--- a/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java
+++ b/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java
@@ -23,6 +23,7 @@ import net.minecraft.network.protocol.game.ClientboundSetEntityDataPacket;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.entity.Entity;
 import org.apache.commons.lang3.ObjectUtils;
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 
 public class SynchedEntityData {
@@ -123,7 +124,7 @@ public class SynchedEntityData {
         return this.itemsById.containsKey(key.getId());
     }
 
-    private <T> SynchedEntityData.DataItem<T> getItem(EntityDataAccessor<T> key) {
+    public <T> SynchedEntityData.DataItem<T> getItem(EntityDataAccessor<T> key) { // MultiPaper - make public
         // Spigot start
         /*
         this.lock.readLock().lock();
@@ -302,6 +303,18 @@ public class SynchedEntityData {
         return list;
     }
 
+    // MultiPaper start - Non-nullable version of packAll
+    @NotNull
+    public List<SynchedEntityData.DataValue<?>> getAll() {
+        List<SynchedEntityData.DataValue<?>> list = new ArrayList<>();
+        for (DataItem<?> dataItem : this.itemsById.values()) {
+            list.add(dataItem.value());
+        }
+
+        return list;
+    }
+    // MultiPaper end
+
     // This method should only be used if the data of an entity could have became desynced
     // due to interactions on the client.
     public void resendPossiblyDesyncedEntity(ServerPlayer player) {
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index cabd3acadcd8d49fb8dcfb207ef6b2fa6e764e7b..2e753e8b3c04621649db383c07a21ec5c1dc7b3a 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -14,6 +14,7 @@ import com.mojang.datafixers.util.Either;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.JsonOps;
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
@@ -109,6 +110,7 @@ import org.bukkit.craftbukkit.generator.CustomChunkGenerator;
 
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
 import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperEntitiesHandler;
 
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
 
@@ -1371,10 +1373,21 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         public void broadcast(Packet<?> packet) {
             Iterator iterator = this.seenBy.iterator();
 
+            // MultiPaper start - Are we ticking this entity?
+            NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(entity);
+            if (!MultiPaper.isExternalPlayer(MultiPaperEntitiesHandler.getControllingPassenger(entity)) &&
+                    (MultiPaper.isRealPlayer(MultiPaperEntitiesHandler.getControllingPassenger(entity)) ||
+                    MultiPaper.isChunkLocal(newChunkHolder))) {
+                MultiPaperEntitiesHandler.onEntityUpdate(entity, packet, newChunkHolder); // MultiPaper
+            }
+            // MultiPaper end
+
             while (iterator.hasNext()) {
                 ServerPlayerConnection serverplayerconnection = (ServerPlayerConnection) iterator.next();
 
-                serverplayerconnection.send(packet);
+                if (!MultiPaper.isExternalPlayer(serverplayerconnection.getPlayer())) { // MultiPaper - only send to local players
+                    serverplayerconnection.send(packet);
+                }
             }
 
         }
diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index b74fd7f6c6c2e194384d2acd6b5d72fda5cd517a..2a662d61dc8739b6bb3576a3030119c0c1f10977 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -37,6 +37,7 @@ import net.minecraft.world.entity.decoration.ItemFrame;
 import net.minecraft.world.entity.projectile.AbstractArrow;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.MapItem;
+import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
 import net.minecraft.world.phys.Vec3;
 import org.slf4j.Logger;
@@ -67,7 +68,7 @@ public class ServerEntity {
     private int yHeadRotp;
     private Vec3 ap;
     private int tickCount;
-    private int teleportDelay;
+    public int teleportDelay; // MultiPaper - make public
     private List<Entity> lastPassengers;
     private boolean wasRiding;
     private boolean wasOnGround;
@@ -110,6 +111,16 @@ public class ServerEntity {
             this.lastPassengers = list;
         }
 
+        // MultiPaper start - Entities in vehicles glitch out when crossing borders, this forces them to sync
+        if (!list.isEmpty()) {
+            for (Entity passenger : list) {
+                if (passenger.position().distanceToSqr(this.entity.position()) > 16) {
+                    passenger.setPosRaw(this.entity.getX(), this.entity.getY(), this.entity.getZ());
+                }
+            }
+        }
+        // MultiPaper end
+
         Entity entity = this.entity;
 
         if (!this.trackedPlayers.isEmpty() && entity instanceof ItemFrame) { // Paper - Perf: Only tick item frames if players can see it
@@ -146,7 +157,7 @@ public class ServerEntity {
             int i;
             int j;
 
-            if (this.entity.isPassenger()) {
+            if (!(this.entity instanceof ServerPlayer) && this.entity.isPassenger()) { // MultiPaper - Force full position update for players
                 i = Mth.floor(this.entity.getYRot() * 256.0F / 360.0F);
                 j = Mth.floor(this.entity.getXRot() * 256.0F / 360.0F);
                 boolean flag = Math.abs(i - this.yRotp) >= 1 || Math.abs(j - this.xRotp) >= 1;
@@ -281,6 +292,7 @@ public class ServerEntity {
 
     public void removePairing(ServerPlayer player) {
         this.entity.stopSeenByPlayer(player);
+        if (MultiPaper.isRealPlayer(player)) // MultiPaper - Don't send to external players
         player.connection.send(new ClientboundRemoveEntitiesPacket(new int[]{this.entity.getId()}));
     }
 
@@ -288,8 +300,10 @@ public class ServerEntity {
         List<Packet<ClientGamePacketListener>> list = new ArrayList();
 
         Objects.requireNonNull(list);
+        if (MultiPaper.isRealPlayer(player)) { // MultiPaper - Don't send to external players
         this.sendPairingData(player, list::add);
         player.connection.send(new ClientboundBundlePacket(list));
+        } // MultiPaper - Don't send to external players
         this.entity.startSeenByPlayer(player);
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index c8b93fd8fa56ac27165452692d3bd97e7b3256a9..8ba7b7ac81daebdbe3089f9b6a7684cd9cc1bbde 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -103,8 +103,11 @@ import net.minecraft.world.entity.animal.WaterAnimal;
 import net.minecraft.world.entity.animal.horse.SkeletonHorse;
 import net.minecraft.world.entity.boss.EnderDragonPart;
 import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
+import net.minecraft.world.entity.decoration.ArmorStand;
 import net.minecraft.world.entity.npc.Npc;
 import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.entity.projectile.FireworkRocketEntity;
+import net.minecraft.world.entity.projectile.FishingHook;
 import net.minecraft.world.entity.raid.Raid;
 import net.minecraft.world.entity.raid.Raids;
 import net.minecraft.world.flag.FeatureFlagSet;
@@ -183,6 +186,7 @@ import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
 import puregero.multipaper.MultiPaper;
 import puregero.multipaper.MultiPaperChunkHandler;
+import puregero.multipaper.MultiPaperEntitiesHandler;
 import puregero.multipaper.externalserverprotocol.TimeUpdatePacket;
 
 public class ServerLevel extends Level implements WorldGenLevel {
@@ -922,7 +926,9 @@ public class ServerLevel extends Level implements WorldGenLevel {
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             //this.timings.entityTick.startTiming(); // Spigot // Purpur
             this.entityTickList.forEach((entity) -> {
+                if (!MultiPaperEntitiesHandler.tickEntity(entity)) return; // MultiPaper - should we tick this entity?
                 entity.activatedPriorityReset = false; // Pufferfish - DAB
+
                 if (!entity.isRemoved()) {
                     if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
                         entity.discard();
@@ -1790,6 +1796,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 return false;
             }
             // CraftBukkit end
+            MultiPaperEntitiesHandler.onEntitySpawn(entity); // MultiPaper
 
             return this.entityLookup.addNewEntity(entity); // Paper - rewrite chunk system
         }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 22095d4d387db702229395e0a5550311318d1dfa..292002a7758c8ac7ed9bcc373d12d3081b924956 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -1441,7 +1441,7 @@ public class ServerPlayer extends Player {
     @Override
     public void take(Entity item, int count) {
         super.take(item, count);
-        this.containerMenu.broadcastChanges();
+        if (!MultiPaperEntitiesHandler.takingItem) this.containerMenu.broadcastChanges(); // MultiPaper
     }
 
     // CraftBukkit start - moved bed result checks from below into separate method
@@ -2246,10 +2246,17 @@ public class ServerPlayer extends Player {
             this.server.server.getPluginManager().callEvent(event);
             this.server.server.getPluginManager().callEvent(new com.destroystokyo.paper.event.player.PlayerLocaleChangeEvent(this.getBukkitEntity(), this.language, clientOptions.language())); // Paper
         }
+        this.locale = packet.language;
+        // Paper start
+        this.adventure$locale = net.kyori.adventure.translation.Translator.parseLocale(this.locale);
+        if (!(this instanceof ExternalPlayer)) { // MultiPaper
+        this.connection.connection.channel.attr(PaperAdventure.LOCALE_ATTRIBUTE).set(this.adventure$locale);
+        } // MultiPaper
         // CraftBukkit end
         // Paper start - don't call options events on login
         updateOptionsNoEvents(clientOptions);
     }
+
     public void updateOptionsNoEvents(ClientInformation clientOptions) {
         // Paper end
         this.language = clientOptions.language();
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 1888be4cc65135c1cfce7b207eefc0ca7540c3a3..6965721f527944729a84b4efa97587b5ca545994 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -245,6 +245,7 @@ import puregero.multipaper.ExternalPlayer;
 import puregero.multipaper.MultiPaper;
 import puregero.multipaper.MultiPaperAckBlockChangesHandler;
 import puregero.multipaper.MultiPaperInventoryHandler;
+import puregero.multipaper.MultiPaperPlayerHandler;
 import puregero.multipaper.externalserverprotocol.PlayerActionPacket;
 import puregero.multipaper.externalserverprotocol.PlayerRemovePacket;
 // CraftBukkit end
@@ -3504,6 +3505,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     @Override
     public void handlePlayerAbilities(ServerboundPlayerAbilitiesPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
+        MultiPaperPlayerHandler.handlePlayerAbilities(this.player, packet); // MultiPaper
         // CraftBukkit start
         if (this.player.getAbilities().mayfly && this.player.getAbilities().flying != packet.isFlying()) {
             PlayerToggleFlightEvent event = new PlayerToggleFlightEvent(this.player.getBukkitEntity(), packet.isFlying());
@@ -3527,6 +3529,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             return;
         }
         // Paper end - do not accept invalid information
+        MultiPaperPlayerHandler.handleClientInformation(this.player, packet); // MultiPaper
         this.player.updateOptions(packet.information());
         this.connection.channel.attr(io.papermc.paper.adventure.PaperAdventure.LOCALE_ATTRIBUTE).set(net.kyori.adventure.translation.Translator.parseLocale(packet.information().language())); // Paper
     }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 0ea3826d9b5bd810a4399b18524dbe220c7b9c6b..ed67f36f3bbabd150bfeb3efc3125c4a4843001e 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -125,10 +125,7 @@ import org.bukkit.event.player.PlayerSpawnChangeEvent;
 import puregero.multipaper.ExternalPlayer;
 import puregero.multipaper.ExternalServerConnection;
 import puregero.multipaper.MultiPaper;
-import puregero.multipaper.externalserverprotocol.PlayerChangeDimensionPacket;
-import puregero.multipaper.externalserverprotocol.PlayerCreatePacket;
-import puregero.multipaper.externalserverprotocol.PlayerRemovePacket;
-import puregero.multipaper.externalserverprotocol.PlayerRespawnPacket;
+import puregero.multipaper.externalserverprotocol.*;
 // CraftBukkit end
 
 public abstract class PlayerList {
@@ -379,6 +376,8 @@ public abstract class PlayerList {
         }
         // CraftBukkit end
 
+        MultiPaper.onPlayerJoin(player); // MultiPaper
+
         // CraftBukkit start - sendAll above replaced with this loop
         ClientboundPlayerInfoUpdatePacket packet = ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(player)); // Paper - Add Listing API for Player
 
@@ -1048,6 +1047,7 @@ public abstract class PlayerList {
 
                 if (subscribedToSoruce && subscribedToDestination) {
                     externalServer.getConnection().send(new PlayerChangeDimensionPacket(entityplayer1, !flag));
+                    externalServer.getConnection().send(new EntityUpdatePacket(entityplayer1, new ClientboundSetEntityDataPacket(entityplayer1.getId(), entityplayer1.getEntityData().getAll())));
                 } else if (subscribedToDestination) {
                     serversToCreatePlayerOn.add(externalServer.getConnection());
                 } else if (subscribedToSoruce) {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index f8d94039d204962e238513f7b998f7054377d2a5..603d69ab778825323c1b2588f5922f4c3bef4960 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -150,7 +150,10 @@ import org.bukkit.event.entity.EntityPoseChangeEvent;
 import org.bukkit.event.entity.EntityRemoveEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.plugin.PluginManager;
+import puregero.multipaper.ExternalServer;
 import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperEntitiesHandler;
+import puregero.multipaper.externalserverprotocol.EntityRemovePacket;
 // CraftBukkit end
 
 public abstract class Entity implements Nameable, EntityAccess, CommandSource, ScoreHolder {
@@ -351,12 +354,13 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     public static final int FLAG_INVISIBLE = 5;
     protected static final int FLAG_GLOWING = 6;
     protected static final int FLAG_FALL_FLYING = 7;
+    public boolean isSyncing = false;  // MultiPaper - add isSyncing
     private static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
     private static final EntityDataAccessor<Optional<Component>> DATA_CUSTOM_NAME = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.OPTIONAL_COMPONENT);
     private static final EntityDataAccessor<Boolean> DATA_CUSTOM_NAME_VISIBLE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
     private static final EntityDataAccessor<Boolean> DATA_SILENT = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
     private static final EntityDataAccessor<Boolean> DATA_NO_GRAVITY = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
-    protected static final EntityDataAccessor<net.minecraft.world.entity.Pose> DATA_POSE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.POSE);
+    public static final EntityDataAccessor<net.minecraft.world.entity.Pose> DATA_POSE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.POSE); // MultiPaper - make public
     private static final EntityDataAccessor<Integer> DATA_TICKS_FROZEN = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
     private EntityInLevelCallback levelCallback;
     private final VecDeltaCodec packetPositionCodec;
@@ -2348,7 +2352,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         } else {
             String s = this.getEncodeId();
 
-            if (!this.persist || s == null) { // CraftBukkit - persist flag
+            if ((!isSyncing && !this.persist) || s == null) { // CraftBukkit - persist flag // MultiPaper - only use the persist flag if we're not syncing between servers
                 return false;
             } else {
                 nbttagcompound.putString("id", s);
@@ -2368,7 +2372,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     }
     // Paper end - Entity serialization api
     public boolean save(CompoundTag nbt) {
-        return this.isPassenger() ? false : this.saveAsPassenger(nbt);
+        return !this.isSyncing && this.isPassenger() ? false : this.saveAsPassenger(nbt); // MultiPaper - Save passengers when syncing
     }
 
     public CompoundTag saveWithoutId(CompoundTag nbt) {
@@ -2704,7 +2708,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         EntityType<?> entitytypes = this.getType();
         ResourceLocation minecraftkey = EntityType.getKey(entitytypes);
 
-        return entitytypes.canSerialize() && minecraftkey != null ? minecraftkey.toString() : null;
+        return (entitytypes.canSerialize() || (isSyncing && !(this instanceof ServerPlayer))) && minecraftkey != null ? minecraftkey.toString() : null; // MultiPaper - add isSyncing
+        // Paper end
     }
 
     // CraftBukkit start - allow excluding certain data when saving
@@ -2978,7 +2983,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
                 if (entity.getBukkitEntity() instanceof Vehicle && this.getBukkitEntity() instanceof LivingEntity) {
                     VehicleEnterEvent event = new VehicleEnterEvent((Vehicle) entity.getBukkitEntity(), this.getBukkitEntity());
                     // Suppress during worldgen
-                    if (this.valid) {
+                    if (this.valid && !MultiPaperEntitiesHandler.modifyingPassengers) { // MultiPaper - don't call VehicleEnterEvent if we're syncing the passengers from another server
                         Bukkit.getPluginManager().callEvent(event);
                     }
                     if (event.isCancelled()) {
@@ -2988,7 +2993,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
 
                 EntityMountEvent event = new EntityMountEvent(this.getBukkitEntity(), entity.getBukkitEntity());
                 // Suppress during worldgen
-                if (this.valid) {
+                if (this.valid && !MultiPaperEntitiesHandler.modifyingPassengers) { // MultiPaper - don't call EntityMountEvent if we're syncing the passengers from another server
                     Bukkit.getPluginManager().callEvent(event);
                 }
                 if (event.isCancelled()) {
@@ -3023,6 +3028,15 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
 
     }
 
+    // MultiPaper start - allow for removing passengers when unloading an external chunk
+    public void forceEjectPassengers() {
+        for (Entity passenger : this.passengers) {
+            passenger.vehicle = null;
+        }
+        this.passengers = ImmutableList.of();
+    }
+    // MultiPaper end
+
     public void removeVehicle() {
         // Paper start - Force entity dismount during teleportation
         stopRiding(false);
@@ -3087,7 +3101,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
                         (LivingEntity) entity.getBukkitEntity(), !suppressCancellation // Paper - Force entity dismount during teleportation
                 );
                 // Suppress during worldgen
-                if (this.valid) {
+                if (this.valid && !MultiPaperEntitiesHandler.modifyingPassengers) { // MultiPaper - don't call VehicleExitEvent if we're syncing the passengers from another server
                     Bukkit.getPluginManager().callEvent(event);
                 }
                 CraftEntity craftn = (CraftEntity) entity.getBukkitEntity().getVehicle();
@@ -3099,7 +3113,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
 
             EntityDismountEvent event = new EntityDismountEvent(entity.getBukkitEntity(), this.getBukkitEntity(), !suppressCancellation); // Paper - Force entity dismount during teleportation
             // Suppress during worldgen
-            if (this.valid) {
+            if (this.valid && !MultiPaperEntitiesHandler.modifyingPassengers) { // MultiPaper - don't call EntityDismountEvent if we're syncing the passengers from another server
                 Bukkit.getPluginManager().callEvent(event);
             }
             if (event.isCancelled()) {
@@ -4326,7 +4340,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         return true;
     }
 
-    private Stream<Entity> getIndirectPassengersStream() {
+    public Stream<Entity> getIndirectPassengersStream() { // MultiPaper - Make public
         if (this.passengers.isEmpty()) { return Stream.of(); } // Paper - Optimize indirect passenger iteration
         return this.passengers.stream().flatMap(Entity::getSelfAndPassengers);
     }
@@ -4809,6 +4823,10 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
             int j = Mth.floor(y);
             int k = Mth.floor(z);
 
+            if ((i >> 4) != (this.blockPosition.getX() >> 4) || (k >> 4) != (this.blockPosition.getZ() >> 4)) {
+                MultiPaperEntitiesHandler.onChunkMove(this, new BlockPos(i, j, k), this.blockPosition);
+            }
+
             if (i != this.blockPosition.getX() || j != this.blockPosition.getY() || k != this.blockPosition.getZ()) {
                 this.blockPosition = new BlockPos(i, j, k);
                 this.feetBlockState = null;
@@ -4929,9 +4947,13 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
             return;
         }
         // Paper end - rewrite chunk system
+        final boolean alreadyRemoved = this.removalReason != null;
+
+        MultiPaperEntitiesHandler.onEntityRemove(this, removalReason); // MultiPaper
+        EntityRemovePacket.setEntityRemoved(this.getUUID(), removalReason); // MultiPaper
+
         CraftEventFactory.callEntityRemoveEvent(this, cause);
         // CraftBukkit end
-        final boolean alreadyRemoved = this.removalReason != null; // Paper - Folia schedulers
         if (this.removalReason == null) {
             this.removalReason = entity_removalreason;
         }
@@ -4950,6 +4972,18 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         // Paper end - Folia schedulers
     }
 
+    // MultiPaper start - force removal
+    public void forceRemove() {
+        io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot remove entity off-main");
+        if (!((ServerLevel)this.level).getEntityLookup().canRemoveEntity(this)) {
+            LOGGER.warn("forceRemove - Entity " + this + " is currently prevented from being removed from the world since it is processing section status updates", new Throwable());
+            return;
+        }
+
+        this.removalReason = RemovalReason.UNLOADED_TO_CHUNK;
+        this.levelCallback.onRemove(this.removalReason);
+    }
+
     public void unsetRemoved() {
         this.removalReason = null;
     }
@@ -4971,7 +5005,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
 
     @Override
     public boolean shouldBeSaved() {
-        return this.removalReason != null && !this.removalReason.shouldSave() ? false : (this.isPassenger() ? false : !this.isVehicle() || !this.hasAnyPlayerPassengers()); // Paper - rewrite chunk system - it should check if the entity has ANY player passengers
+        return !getType().canSerialize() || (this.removalReason != null && !this.removalReason.shouldSave()) ? false : (this.isPassenger() ? false : !this.isVehicle() || !this.hasAnyPlayerPassengers()); // Paper - rewrite chunk system - it should check if the entity has ANY player passengers // MultiPaper - if they can't be serialized, they also can't be saved
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index d6705dce3bc8c1964184fe425386b3f3c0a8202e..05b3ee1fb8541be926dbdebf90b63a2be0681957 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -141,6 +141,8 @@ import org.bukkit.event.entity.EntityRemoveEvent;
 import org.bukkit.event.entity.EntityResurrectEvent;
 import org.bukkit.event.entity.EntityTeleportEvent;
 import org.bukkit.event.player.PlayerItemConsumeEvent;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.externalserverprotocol.EntityUpdatePacket;
 // CraftBukkit end
 
 
@@ -3392,6 +3394,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
 
     // Paper start - prevent oversized data
     public static ItemStack sanitizeItemStack(final ItemStack itemStack, final boolean copyItemStack) {
+        if (EntityUpdatePacket.threadsWritingUpdatePackets.contains(Thread.currentThread().getId())) return itemStack; // MultiPaper - don't run when we're sending internal packets
         if (itemStack.isEmpty() || !itemStack.hasTag()) {
             return itemStack;
         }
diff --git a/src/main/java/net/minecraft/world/entity/Mob.java b/src/main/java/net/minecraft/world/entity/Mob.java
index dd275ece5887f5215cb785564af27152b29b370e..012579dac7e89cc1053179f29b92f82a884b015b 100644
--- a/src/main/java/net/minecraft/world/entity/Mob.java
+++ b/src/main/java/net/minecraft/world/entity/Mob.java
@@ -1616,7 +1616,7 @@ public abstract class Mob extends LivingEntity implements Targeting {
         return flag1;
     }
 
-    private void restoreLeashFromSave() {
+    public void restoreLeashFromSave() { // MultiPaper - make public
         if (this.leashInfoTag != null && this.level() instanceof ServerLevel) {
             if (this.leashInfoTag.hasUUID("UUID")) {
                 UUID uuid = this.leashInfoTag.getUUID("UUID");
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index 43199815ffe3d666577390b96187aa898ceb910e..5b77293cd57a229df40918129a0a20f1c8b9fc9d 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -145,7 +145,7 @@ public abstract class Player extends LivingEntity {
     private static final EntityDataAccessor<Float> DATA_PLAYER_ABSORPTION_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.FLOAT);
     private static final EntityDataAccessor<Integer> DATA_SCORE_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.INT);
     public static final EntityDataAccessor<Byte> DATA_PLAYER_MODE_CUSTOMISATION = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
-    protected static final EntityDataAccessor<Byte> DATA_PLAYER_MAIN_HAND = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
+    public static final EntityDataAccessor<Byte> DATA_PLAYER_MAIN_HAND = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE); // MultiPaper - make public
     protected static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_LEFT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
     protected static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_RIGHT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
     private long timeEntitySatOnShoulder;
diff --git a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
index 91497f5e6c07fcf1b05eca6846c51e1a15ed3bc0..3d8e6f51cd49ee008976fc50f67a4419ec61c30d 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
@@ -50,6 +50,7 @@ import org.bukkit.entity.Player;
 import org.bukkit.entity.FishHook;
 import org.bukkit.event.entity.EntityRemoveEvent;
 import org.bukkit.event.player.PlayerFishEvent;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public class FishingHook extends Projectile {
@@ -312,6 +313,7 @@ public class FishingHook extends Projectile {
     }
 
     private void catchingFish(BlockPos pos) {
+        if (!MultiPaper.isChunkLocal(this.level().getChunkIfLoaded(blockPosition()))) return; // MultiPaper - Only catch fish on our own chunks
         ServerLevel worldserver = (ServerLevel) this.level();
         int i = 1;
         BlockPos blockposition1 = pos.above();
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
index f66a1e775813135858a25dc1ed612c8717434a2f..a3c0bb4f29ccc89d7d7b6103763c486289320b26 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
@@ -24,6 +24,7 @@ import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.entity.ChunkEntities;
 import net.minecraft.world.level.entity.EntityPersistentStorage;
 import org.slf4j.Logger;
+import puregero.multipaper.MultiPaperEntitiesHandler;
 
 public class EntityStorage implements EntityPersistentStorage<Entity> {
     private static final Logger LOGGER = LogUtils.getLogger();
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
index fe312b1aef579cb4bf81bdd967cf72ff880d7505..18fbd66bd1c5ba311aff4e248294cf71ccd2c386 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
@@ -16,6 +16,7 @@ import net.minecraft.nbt.NbtIo;
 import net.minecraft.nbt.StreamTagVisitor;
 import net.minecraft.util.ExceptionCollector;
 import net.minecraft.world.level.ChunkPos;
+import puregero.multipaper.MultiPaper;
 
 public class RegionFileStorage implements AutoCloseable {
 
@@ -89,7 +90,7 @@ public class RegionFileStorage implements AutoCloseable {
             return null;
         }
     }
-    
+
     public synchronized RegionFile getRegionFileIfLoaded(ChunkPos chunkcoordintpair) {
         return this.regionCache.getAndMoveToFirst(ChunkPos.asLong(chunkcoordintpair.getRegionX(), chunkcoordintpair.getRegionZ()));
     }
@@ -190,6 +191,7 @@ public class RegionFileStorage implements AutoCloseable {
 
     @Nullable
     public CompoundTag read(ChunkPos pos) throws IOException {
+        if (true) return MultiPaper.readRegionFileNBT(folder.toFile(), pos); // MultiPaper
         // CraftBukkit start - SPIGOT-5680: There's no good reason to preemptively create files on read, save that for writing
         RegionFile regionfile = this.getRegionFile(pos, true, true); // Paper
         if (regionfile == null) {
@@ -298,7 +300,14 @@ public class RegionFileStorage implements AutoCloseable {
 
     protected void write(ChunkPos pos, @Nullable CompoundTag nbt) throws IOException {
         // Paper start - rewrite chunk system
-        RegionFile regionfile = this.getRegionFile(pos, nbt == null, true); // CraftBukkit
+        // MultiPaper start
+        if (true) {
+            MultiPaper.writeRegionFileNBT(folder.toFile(), pos, nbt);
+            return;
+        }
+        // MultiPaper end
+
+        RegionFile regionfile = this.getRegionFile(pos, nbt == null, true); // CraftBukkit // Paper // Paper start - rewrite chunk system
         if (nbt == null && regionfile == null) {
             return;
         }
diff --git a/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java b/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
index 163b9fc892351f31836a5d9b166a1337bc682141..4c6cfce04c513bec3335c959b5221a5346dcacc1 100644
--- a/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
+++ b/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
@@ -4,6 +4,7 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
@@ -26,11 +27,14 @@ import net.minecraft.util.CsvOutput;
 import net.minecraft.util.VisibleForDebug;
 import net.minecraft.world.entity.Entity;
 import org.slf4j.Logger;
+import net.minecraft.world.entity.Mob;
 import net.minecraft.world.level.ChunkPos;
 // CraftBukkit start
 import net.minecraft.world.level.chunk.storage.EntityStorage;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.entity.EntityRemoveEvent;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.externalserverprotocol.EntityUpdateNBTPacket;
 // CraftBukkit end
 
 public class PersistentEntitySectionManager<T extends EntityAccess> implements AutoCloseable {
@@ -43,9 +47,9 @@ public class PersistentEntitySectionManager<T extends EntityAccess> implements A
     final EntitySectionStorage<T> sectionStorage;
     private final LevelEntityGetter<T> entityGetter;
     private final Long2ObjectMap<Visibility> chunkVisibility = new Long2ObjectOpenHashMap();
-    private final Long2ObjectMap<PersistentEntitySectionManager.ChunkLoadStatus> chunkLoadStatuses = new Long2ObjectOpenHashMap();
+    public final Long2ObjectMap<PersistentEntitySectionManager.ChunkLoadStatus> chunkLoadStatuses = new Long2ObjectOpenHashMap(); // MultiPaper - make public
     private final LongSet chunksToUnload = new LongOpenHashSet();
-    private final Queue<ChunkEntities<T>> loadingInbox = Queues.newConcurrentLinkedQueue();
+    public final Queue<ChunkEntities<T>> loadingInbox = Queues.newConcurrentLinkedQueue(); // MultiPaper - make public
 
     public PersistentEntitySectionManager(Class<T> entityClass, LevelCallback<T> handler, EntityPersistentStorage<T> dataAccess) {
         this.sectionStorage = new EntitySectionStorage<>(entityClass, this.chunkVisibility);
@@ -305,14 +309,26 @@ public class PersistentEntitySectionManager<T extends EntityAccess> implements A
         ChunkEntities<T> chunkentities; // CraftBukkit - decompile error
 
         while ((chunkentities = (ChunkEntities) this.loadingInbox.poll()) != null) {
+            // Multipaper start - Sometimes chunks already have entities loaded? Send these to subscribed chunks
+            List<Entity> existingEntities = getEntities(chunkentities.getPos()).stream().filter(entity -> entity.shouldBeSaved()).toList();
+            // MultiPaper end
             chunkentities.getEntities().forEach((entityaccess) -> {
                 this.addEntity(entityaccess, true);
+                if (entityaccess instanceof Mob mob) mob.restoreLeashFromSave(); // MultiPaper
             });
             this.chunkLoadStatuses.put(chunkentities.getPos().toLong(), PersistentEntitySectionManager.ChunkLoadStatus.LOADED);
             // CraftBukkit start - call entity load event
             List<Entity> entities = this.getEntities(chunkentities.getPos());
             CraftEventFactory.callEntitiesLoadEvent(((EntityStorage) this.permanentStorage).level, chunkentities.getPos(), entities);
             // CraftBukkit end
+            // Multipaper start - Sometimes chunks already have entities loaded? Send these to subscribed chunks
+            NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(((EntityStorage) this.permanentStorage).level, chunkentities.getPos().x, chunkentities.getPos().z);
+            if (newChunkHolder != null) {
+                for (Entity existingEntity : existingEntities) {
+                    MultiPaper.broadcastPacketToExternalServers(newChunkHolder.externalEntitiesSubscribers, () -> new EntityUpdateNBTPacket(existingEntity));
+                }
+            }
+            // MultiPaper end
         }
 
     }
@@ -437,7 +453,7 @@ public class PersistentEntitySectionManager<T extends EntityAccess> implements A
         return this.visibleEntityStorage.count();
     }
 
-    private static enum ChunkLoadStatus {
+    public static enum ChunkLoadStatus { // MultiPaper - make public
 
         FRESH, PENDING, LOADED;
 
diff --git a/src/main/java/puregero/multipaper/ExternalPlayer.java b/src/main/java/puregero/multipaper/ExternalPlayer.java
index e7085ebe21c98fbe3948681238fffedbbb10d56f..7078760981e3c74154f00275ac46c03d19bd0d50 100644
--- a/src/main/java/puregero/multipaper/ExternalPlayer.java
+++ b/src/main/java/puregero/multipaper/ExternalPlayer.java
@@ -7,6 +7,7 @@ import net.minecraft.network.PacketSendListener;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketFlow;
 import net.minecraft.network.protocol.game.*;
+import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
@@ -16,10 +17,13 @@ import org.apache.logging.log4j.Logger;
 import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.externalserverprotocol.EntityUpdatePacket;
 
 import javax.annotation.Nullable;
 import java.net.InetSocketAddress;
+import java.util.Collections;
 import java.util.HashMap;
+import java.util.List;
 import java.util.UUID;
 
 public class ExternalPlayer extends ServerPlayer {
@@ -30,6 +34,7 @@ public class ExternalPlayer extends ServerPlayer {
     public ExternalServerConnection externalServerConnection;
     private final InetSocketAddress address;
     private boolean sendPackets = true;
+    public boolean updatingData = false;
 
     public static ExternalPlayer create(ExternalServerConnection externalServerConnection, GameProfile gameProfile, String world, double x, double y, double z, float yaw, float pitch, GameType gamemode, InetSocketAddress address, CompoundTag saveData, String advancements, String stats) {
         loadedAdvancements.put(gameProfile.getId(), advancements);
@@ -45,13 +50,23 @@ public class ExternalPlayer extends ServerPlayer {
         this.externalServerConnection = externalServerConnection;
         this.address = address;
         this.isRealPlayer = true;
-        this.didPlayerJoinEvent = true;
         this.valid = true;
         this.onGround = true;
         connection = new ServerGamePacketListenerImpl(getServer(), new ExternalPlayerConnection(PacketFlow.CLIENTBOUND), this);
         setPos(x, y, z);
         setYRot(yaw);
         setXRot(pitch);
+
+        for (int i = 0; i < getServer().getPlayerList().players.size(); ++i) {
+            ServerPlayer entityplayer1 = getServer().getPlayerList().players.get(i);
+
+            if (!entityplayer1.getBukkitEntity().canSee(getBukkitEntity())) {
+                continue;
+            }
+
+            entityplayer1.connection.send(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(this)));
+        }
+
         getServer().getPlayerList().addPlayer(this);
         ((ServerLevel) level()).addNewPlayer(this);
         sendPackets = false;
@@ -103,12 +118,15 @@ public class ExternalPlayer extends ServerPlayer {
     }
 
     @Override
-    public boolean broadcastToPlayer(ServerPlayer spectator) {
-        return false;
+    public void checkInsideBlocks() {
+        super.checkInsideBlocks();
     }
 
     @Override
-    public void checkInsideBlocks() {
-        super.checkInsideBlocks();
+    public void onSyncedDataUpdated(EntityDataAccessor<?> data) {
+        if (!updatingData) {
+            MultiPaper.broadcastPacketToExternalServers(new EntityUpdatePacket(this,
+                    new ClientboundSetEntityDataPacket(getId(), Collections.singletonList(getEntityData().getItem(data).value()))));
+        }
     }
 }
diff --git a/src/main/java/puregero/multipaper/ExternalServerConnection.java b/src/main/java/puregero/multipaper/ExternalServerConnection.java
index 0f9d51e2959a9bf2b3b31930c88a942a777a6d56..727b613ae30c3266c2fc5f5a13d2622f6bf4ad7c 100644
--- a/src/main/java/puregero/multipaper/ExternalServerConnection.java
+++ b/src/main/java/puregero/multipaper/ExternalServerConnection.java
@@ -42,6 +42,7 @@ public class ExternalServerConnection extends ChannelInitializer<SocketChannel>
     public final ConcurrentHashMap<ChunkKey, Consumer<DataInputStream>> chunkCallbacks = new ConcurrentHashMap<>();
     public long lastPacketSent = 0;
     public long lastPacketReceived = 0;
+    public final ConcurrentHashMap<ChunkKey, Consumer<DataInputStream>> entitiesCallbacks = new ConcurrentHashMap<>();
 
     public ExternalServerConnection() {
 
@@ -196,4 +197,15 @@ public class ExternalServerConnection extends ChannelInitializer<SocketChannel>
         RequestChunkPacket.blocker = externalServer;
         send(new RequestChunkPacket(world, cx, cz));
     }
+
+    public void requestEntities(String world, int cx, int cz, Consumer<DataInputStream> callback) {
+        if (callback != null) {
+            if (entitiesCallbacks.put(new ChunkKey(world, cx, cz), callback) != null) {
+                LOGGER.warn("An entities callback already existed for " + world + ", " + cx + ", " + cz + " (new request is to " + externalServer.getName() + ")");
+                LOGGER.warn("Stats for " + externalServer.getName() + ": last packet sent=" + (System.currentTimeMillis() - lastPacketSent) + "ms ago; last packet received=" + (System.currentTimeMillis() - lastPacketReceived) + "ms ago");
+            }
+        }
+
+        send(new RequestEntitiesPacket(world, cx, cz));
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index 887fb303c8b179ee48dbf6aaa55fcf3143f8d206..d1109890382eadc3155c6f25b17140a6ea4b44d9 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -131,6 +131,8 @@ public class MultiPaper {
                 broadcastPacketToExternalServers(new TimeUpdatePacket(level));
             }
         }
+
+        RequestEntityPacket.tick();
     }
 
     public static void sendTickTime(long time, double tps) {
@@ -325,6 +327,8 @@ public class MultiPaper {
                         RequestChunkPacket.blocker = null;
                         future.complete(inputStream);
                     });
+                } else if (path.equals("entities")) {
+                    server.getConnection().requestEntities(world, cx, cz, future::complete);
                 } else {
                     throw new IllegalArgumentException("Cannot load a " + path + " chunk from an external server");
                 }
@@ -486,6 +490,7 @@ public class MultiPaper {
 
     public static void unlockChunk(NewChunkHolder newChunkHolder, ChunkAccess chunkAccess, ChunkEntitySlices chunkEntitySlices) {
         if (chunkAccess instanceof LevelChunk levelChunk && MultiPaper.isChunkLocal(newChunkHolder)) {
+            broadcastPacketToExternalServers(newChunkHolder.externalEntitiesSubscribers, () -> new SendEntitiesPacket(levelChunk, chunkEntitySlices));
             broadcastPacketToExternalServers(newChunkHolder.externalSubscribers, () -> new SendTickListPacket(levelChunk));
             for (BlockEntity blockEntity : levelChunk.getBlockEntities().values()) {
                 if (blockEntity instanceof Container container) {
@@ -565,6 +570,10 @@ public class MultiPaper {
         return level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(x, z);
     }
 
+    public static NewChunkHolder getChunkHolder(Entity entity) {
+        return getChunkHolder((ServerLevel) entity.level(), entity.chunkPosition().x, entity.chunkPosition().z);
+    }
+
     public static void chunkChangedStatus(ServerLevel level, ChunkPos pos, ChunkStatus status) {
         getConnection().send(new ChunkChangedStatusMessage(level.getWorld().getName(), pos.x, pos.z, BuiltInRegistries.CHUNK_STATUS.getKey(status).toString()));
     }
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
index b5378a7de5530962511b484368c962522b1e7398..8dc7b36e7de84cda9b6b48b6f735cc9995547ec4 100644
--- a/src/main/java/puregero/multipaper/MultiPaperConnection.java
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -12,9 +12,13 @@ import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
 import net.minecraft.core.registries.BuiltInRegistries;
+import io.papermc.paper.util.MCUtil;
+import io.papermc.paper.world.ChunkEntitySlices;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.level.chunk.LevelChunk;
 import org.apache.logging.log4j.LogManager;
@@ -23,7 +27,11 @@ import org.bukkit.Bukkit;
 import org.bukkit.World;
 import org.bukkit.craftbukkit.CraftWorld;
 import puregero.multipaper.config.MultiPaperConfiguration;
+import puregero.multipaper.externalserverprotocol.EntityRemovePacket;
 import puregero.multipaper.externalserverprotocol.SendChunkPacket;
+import puregero.multipaper.externalserverprotocol.EntityUpdateNBTPacket;
+import puregero.multipaper.externalserverprotocol.EntityUpdateWithDependenciesPacket;
+import puregero.multipaper.externalserverprotocol.SendEntitiesPacket;
 import puregero.multipaper.externalserverprotocol.SendTickListPacket;
 import puregero.multipaper.mastermessagingprotocol.MessageBootstrap;
 import puregero.multipaper.mastermessagingprotocol.messages.masterbound.*;
@@ -31,6 +39,7 @@ import puregero.multipaper.mastermessagingprotocol.messages.serverbound.*;
 
 import java.io.File;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
@@ -92,6 +101,9 @@ public class MultiPaperConnection extends ServerBoundMessageHandler {
             for (ServerLevel level : MinecraftServer.getServer().getAllLevels()) {
                 level.chunkTaskScheduler.chunkHolderManager.getChunkHolders().forEach(chunkHolder -> {
                     channel.write(new SubscribeChunkMessage(level.getWorld().getName(), chunkHolder.chunkX, chunkHolder.chunkZ));
+                    if (chunkHolder.getEntityChunk() != null) {
+                        channel.write(new SubscribeEntitiesMessage(level.getWorld().getName(), chunkHolder.chunkX, chunkHolder.chunkZ));
+                    }
                 });
             }
         }
@@ -196,6 +208,7 @@ public class MultiPaperConnection extends ServerBoundMessageHandler {
         if (newChunkHolder != null) {
             if (newChunkHolder.externalOwner != null && newChunkHolder.externalOwner.isMe() && server != null && !server.isMe()) {
                 if (newChunkHolder.getCurrentChunk() instanceof LevelChunk levelChunk) {
+                    server.getConnection().send(new SendEntitiesPacket(levelChunk));
                     server.getConnection().send(new SendTickListPacket(levelChunk));
                 } else {
                     LOGGER.warn("Chunk " + message.cx + ", " + message.cz + " in world " + message.world + " is not a level chunk, but we own it and want to send tick list to " + server.getName());
@@ -311,4 +324,68 @@ public class MultiPaperConnection extends ServerBoundMessageHandler {
             }
         });
     }
+
+    @Override
+    public void handle(AddEntitySubscriberMessage message) {
+        ExternalServer server = getOrCreateServer(message.server);
+
+        MultiPaper.runSync(() -> {
+            NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(message.world, message.cx, message.cz);
+            if (newChunkHolder != null) {
+                newChunkHolder.externalEntitiesSubscribers.add(server);
+            } else {
+                LOGGER.warn("Received an entities subscribe notification for an unloaded chunk " + message.world + ";" + message.cx + ";" + message.cz);
+            }
+        });
+
+        MCUtil.scheduleTask(2, () -> {
+            NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(message.world, message.cx, message.cz);
+            if (newChunkHolder != null) {
+                ChunkEntitySlices chunkEntities = newChunkHolder.getEntityChunk();
+                if (chunkEntities != null) {
+                    // Send players' vehicles and passengers to the new subscriber
+                    Set<Entity> rootVehiclesToSend = new HashSet<>();
+                    for (Entity entity : chunkEntities.entities) {
+                        Entity controllingPassenger = MultiPaperEntitiesHandler.getControllingPassenger(entity.getRootVehicle());
+                        if (MultiPaper.isRealPlayer(controllingPassenger) && controllingPassenger != entity) {
+                            rootVehiclesToSend.add(entity.getRootVehicle());
+                        }
+                    }
+                    rootVehiclesToSend.forEach(entity -> EntityUpdateWithDependenciesPacket.sendVehicleAndPassengersPacketsRecursivelyToServers(entity, List.of(server)));
+                }
+            }
+        });
+    }
+
+    @Override
+    public void handle(RemoveEntitySubscriberMessage message) {
+        ExternalServer server = getOrCreateServer(message.server);
+
+        MultiPaper.runSync(() -> {
+            NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(message.world, message.cx, message.cz);
+            if (newChunkHolder != null) {
+                newChunkHolder.externalEntitiesSubscribers.remove(server);
+            } else {
+                LOGGER.warn("Received an entities unsubscribe notification for an unloaded chunk " + message.world + ";" + message.cx + ";" + message.cz);
+            }
+        });
+    }
+
+    @Override
+    public void handle(EntitySubscribersSyncMessage message) {
+        HashSet<ExternalServer> servers = new HashSet<>();
+        for (String subscriber : message.subscribers) {
+            servers.add(getOrCreateServer(subscriber));
+        }
+
+        MultiPaper.runSync(() -> {
+            NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(message.world, message.cx, message.cz);
+            if (newChunkHolder != null) {
+                newChunkHolder.externalEntitiesSubscribers.clear();
+                newChunkHolder.externalEntitiesSubscribers.addAll(servers);
+            } else {
+                LOGGER.warn("Received an entities subscribe sync notification for an unloaded chunk " + message.world + ";" + message.cx + ";" + message.cz);
+            }
+        });
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/puregero/multipaper/MultiPaperEntitiesHandler.java b/src/main/java/puregero/multipaper/MultiPaperEntitiesHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..3dbfd4bf13c5891fa23b73cbbab828286828d455
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperEntitiesHandler.java
@@ -0,0 +1,388 @@
+package puregero.multipaper;
+
+import com.mojang.datafixers.util.Pair;
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.*;
+import net.minecraft.network.syncher.SynchedEntityData;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.*;
+import net.minecraft.world.entity.ai.attributes.AttributeInstance;
+import net.minecraft.world.entity.ai.attributes.AttributeModifier;
+import net.minecraft.world.entity.decoration.ArmorStand;
+import net.minecraft.world.entity.decoration.LeashFenceKnotEntity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.entity.projectile.FireworkRocketEntity;
+import net.minecraft.world.entity.projectile.FishingHook;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.phys.Vec3;
+import org.apache.commons.lang.ArrayUtils;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.config.MultiPaperConfiguration;
+import puregero.multipaper.externalserverprotocol.*;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.UnsubscribeEntitiesMessage;
+import puregero.multipaper.mastermessagingprotocol.messages.masterbound.WillSaveEntitiesLaterMessage;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class MultiPaperEntitiesHandler {
+
+    private static final Logger LOGGER = LogManager.getLogger(MultiPaperEntitiesHandler.class.getSimpleName());
+    public static boolean removingEntity = false;
+    public static boolean takingItem = false;
+    public static boolean modifyingPassengers = false;
+
+    public static Entity getControllingPassenger(Entity entity) {
+        Entity controller = entity.getRootVehicle();
+        Entity temp;
+
+        while ((temp = getControllingPassengerNonRecursiveButActuallyStillRecursiveJustLessRecursive(controller)) != null && temp != controller) {
+            controller = temp;
+        }
+
+        return controller;
+    }
+
+    private static Entity getControllingPassengerNonRecursiveButActuallyStillRecursiveJustLessRecursive(Entity entity) {
+        if (entity instanceof ServerPlayer serverPlayer) {
+            // Players control themselves
+            return serverPlayer;
+        } else if (entity instanceof FireworkRocketEntity fireworkRocket && fireworkRocket.attachedToEntity != null && fireworkRocket.attachedToEntity.isAlive()) {
+            // Firework rockets are basically a vehicle and need to be controlled by the controller's server
+            return fireworkRocket.attachedToEntity;
+        } else if (entity.getControllingPassenger() != null) {
+            // Vanilla minecraft's way of handling it
+            return entity.getControllingPassenger();
+        } else {
+            // For non-vanilla vehicles, just find the first player passenger
+            for (Entity passenger : entity.getPassengers()) {
+                Entity controller = getControllingPassengerNonRecursiveButActuallyStillRecursiveJustLessRecursive(passenger);
+                if (controller != null) {
+                    return controller;
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @return true if this entity should be ticked, false if it will be ticked
+     *         by another server.
+     */
+    public static boolean tickEntity(Entity entity) {
+        if (MultiPaper.isRealPlayer(getControllingPassenger(entity))) {
+            return true;
+        }
+
+        if (MultiPaper.isExternalPlayer(getControllingPassenger(entity))) {
+            return false;
+        }
+
+        LevelChunk chunk = entity.level().getChunkIfLoaded(entity.blockPosition());
+        if (!MultiPaper.isChunkLocal(chunk)
+                && !(entity instanceof FishingHook)) {
+            if (entity instanceof ArmorStand armorStand) {
+                boolean temp = armorStand.canTick;
+                armorStand.canTick = false;
+                armorStand.tick();
+                armorStand.canTick = temp;
+            }
+
+            if (entity instanceof LivingEntity livingEntity) {
+                if (MultiPaper.isChunkExternal(chunk)) {
+                    livingEntity.setNoActionTime(0);
+                } else {
+                    livingEntity.setNoActionTime(livingEntity.getNoActionTime() + 1);
+                    livingEntity.checkDespawn();
+                }
+            }
+
+            return false;
+        }
+
+        return true;
+    }
+
+    public static void onEntitiesUnload(NewChunkHolder newChunkHolder) {
+        MultiPaper.getConnection().send(new UnsubscribeEntitiesMessage(newChunkHolder.world.convertable.getLevelId(), newChunkHolder.chunkX, newChunkHolder.chunkZ));
+
+        // Clear our cache of other servers that are subscribed to this chunk
+        newChunkHolder.externalEntitiesSubscribers.clear();
+    }
+
+    public static void willWriteEntities(NewChunkHolder newChunkHolder) {
+        MultiPaper.getConnection().send(new WillSaveEntitiesLaterMessage(newChunkHolder.world.convertable.getLevelId(), newChunkHolder.chunkX, newChunkHolder.chunkZ));
+    }
+
+    public static void onChunkMove(Entity entity, BlockPos to, BlockPos from) {
+        if (from.equals(BlockPos.ZERO)) return; // They just spawned
+        if (!entity.shouldBeSaved() && !(!entity.isPassenger() && entity.isVehicle() && entity.hasExactlyOnePlayerPassenger()) && !(MultiPaperConfiguration.get().optimizations.reducePlayerPositionUpdatesInUnloadedChunks && MultiPaper.isRealPlayer(entity))) return; // Entity shouldn't be synced (eg players)
+
+        LevelChunk chunkFrom = entity.level().getChunkIfLoaded(from);
+        LevelChunk chunkTo = entity.level().getChunkIfLoaded(to);
+
+        if (chunkFrom == null || chunkTo == null) {
+            return;
+        }
+
+        Entity controllingPassenger = getControllingPassenger(entity);
+        if (MultiPaper.isRealPlayer(controllingPassenger) || (MultiPaper.isChunkLocal(chunkFrom) && !MultiPaper.isExternalPlayer(controllingPassenger))) {
+            if (!MultiPaper.isChunkLocal(chunkTo)) {
+                // Leaving our jurisdiction, do a full entity update to ensure the new external server has all the required info
+                if (!(entity instanceof ServerPlayer)) { // Ignore players as they aren't ticked by the new external server
+                    MultiPaper.runSync(() -> MultiPaper.broadcastPacketToExternalServers(chunkTo.getChunkHolder().externalEntitiesSubscribers, () -> new EntityUpdateNBTPacket(entity)));
+                }
+            }
+            for (ExternalServer fromServer : chunkFrom.getChunkHolder().externalEntitiesSubscribers) {
+                if (fromServer.getConnection() != null && !chunkTo.getChunkHolder().externalEntitiesSubscribers.contains(fromServer)) {
+                    // Entity is leaving another server's area, make sure they know this
+                    MultiPaper.runSync(() -> fromServer.getConnection().send(new EntityUpdatePacket(entity, new ClientboundTeleportEntityPacket(entity))));
+                }
+            }
+            for (ExternalServer toServer : chunkTo.getChunkHolder().externalEntitiesSubscribers) {
+                if (toServer.getConnection() != null && !chunkFrom.getChunkHolder().externalEntitiesSubscribers.contains(toServer)) {
+                    // Entity is entering another server's area, send them the full entity
+                    MultiPaper.runSync(() -> {
+                        if (entity instanceof ServerPlayer) {
+                            // Ensure the player's position is up to date
+                            MultiPaper.runSync(() -> toServer.getConnection().send(new EntityUpdatePacket(entity, new ClientboundTeleportEntityPacket(entity))));
+                        } else {
+                            MultiPaper.runSync(() -> {
+                                EntityUpdateWithDependenciesPacket.sendVehicleAndPassengersPacketsRecursivelyToServers(entity, List.of(toServer));
+                            });
+                        }
+                    });
+                }
+            }
+        }
+    }
+
+    private static void setRemovedRecursive(Entity entity) {
+        for (Entity passenger : entity.getPassengers()) {
+            if (!(passenger instanceof ServerPlayer)) {
+                setRemovedRecursive(passenger);
+            }
+        }
+        entity.setRemoved(Entity.RemovalReason.UNLOADED_TO_CHUNK);
+    }
+
+    public static void handleEntityUpdate(ExternalServerConnection connection, Entity entity, Packet<?> packet) {
+        if (packet instanceof ClientboundMoveEntityPacket moveEntityPacket) {
+            VecDeltaCodec vecDeltaCodec = new VecDeltaCodec();
+            vecDeltaCodec.setBase(entity.position());
+            Vec3 vector = vecDeltaCodec.decode(moveEntityPacket.getXa(), moveEntityPacket.getYa(), moveEntityPacket.getZa());
+            if (!(entity instanceof ServerPlayer) && !((ServerLevel) entity.level()).areEntitiesLoaded(new ChunkPos(new BlockPos((int) vector.x, (int) vector.y, (int) vector.z)).longKey)) {
+                setRemovedRecursive(entity);
+                return;
+            }
+            entity.preserveMotion = true;
+            setFallDistance(entity, vector.y);
+            if (moveEntityPacket.hasRotation()) {
+                entity.moveTo(vector.x, vector.y, vector.z, moveEntityPacket.getyRot() * 360f / 256, moveEntityPacket.getxRot() * 360f / 256);
+            } else {
+                // Include y-rot and x-rot, as without it, it teleports players
+                entity.moveTo(vector.x, vector.y, vector.z, entity.getYRot(), entity.getXRot());
+            }
+            entity.onGround = moveEntityPacket.isOnGround();
+        } else if (packet instanceof ClientboundTeleportEntityPacket teleportEntityPacket) {
+            if (!(entity instanceof ServerPlayer) &&!((ServerLevel) entity.level()).areEntitiesLoaded(new ChunkPos(new BlockPos((int) teleportEntityPacket.getX(), (int) teleportEntityPacket.getY(), (int) teleportEntityPacket.getZ())).longKey)) {
+                setRemovedRecursive(entity);
+                return;
+            }
+            entity.preserveMotion = true;
+            setFallDistance(entity, teleportEntityPacket.getY());
+            entity.moveTo(teleportEntityPacket.getX(), teleportEntityPacket.getY(), teleportEntityPacket.getZ(), teleportEntityPacket.getyRot() * 360f / 256, teleportEntityPacket.getxRot() * 360f / 256);
+            entity.onGround = teleportEntityPacket.isOnGround();
+        } else if (packet instanceof ClientboundSetEntityMotionPacket setEntityMotionPacket) {
+            entity.setDeltaMovement(setEntityMotionPacket.getXa() / 8000.0D, setEntityMotionPacket.getYa() / 8000.0D, setEntityMotionPacket.getZa() / 8000.0D);
+        } else if (packet instanceof ClientboundRotateHeadPacket rotateHeadPacket) {
+            entity.setYHeadRot(rotateHeadPacket.getYHeadRot() * 360f / 256);
+        } else if (packet instanceof ClientboundSetEntityDataPacket setEntityDataPacket) {
+            if (entity instanceof ExternalPlayer) {
+                ((ExternalPlayer) entity).updatingData = true;
+            }
+
+            entity.getEntityData().assignValues(setEntityDataPacket.packedItems());
+            if (entity instanceof LivingEntity livingEntity) {
+                for (SynchedEntityData.DataValue<?> item : setEntityDataPacket.packedItems()) {
+                    if (item.id() == LivingEntity.DATA_HEALTH_ID.getId()) {
+                        // Dumb CraftBukkit needs us to set the health using setHealth instead of simply updating the entity data
+                        livingEntity.setHealth((Float) item.value());
+                    }
+                }
+            }
+
+            // Due 1.19.3 packet changes when apply the values we should resync it to local players.
+            if (entity.tracker != null) {
+                entity.tracker.seenBy.forEach(serverplayerconnection -> {
+                    if (MultiPaper.isRealPlayer(serverplayerconnection.getPlayer())) {
+                        entity.getEntityData().refresh(serverplayerconnection.getPlayer());
+                    }
+                });
+            }
+
+            if (entity instanceof ExternalPlayer) {
+                ((ExternalPlayer) entity).updatingData = false;
+            }
+        } else if (packet instanceof ClientboundUpdateAttributesPacket updateAttributesPacket) {
+            for (ClientboundUpdateAttributesPacket.AttributeSnapshot snapshot : updateAttributesPacket.getValues()) {
+                AttributeInstance instance = ((LivingEntity) entity).getAttribute(snapshot.getAttribute());
+                instance.setBaseValue(snapshot.getBase());
+                instance.removeModifiers();
+                for (AttributeModifier modifier : snapshot.getModifiers()) {
+                    instance.addPermanentModifier(modifier);
+                }
+            }
+        } else if (packet instanceof ClientboundAnimatePacket animatePacket) {
+            ChunkMap.TrackedEntity trackedEntity = entity.tracker;
+            if (trackedEntity != null) {
+                trackedEntity.broadcast(new ClientboundAnimatePacket(entity, animatePacket.getAction()));
+            }
+        } else if (packet instanceof ClientboundDamageEventPacket damageEventPacket) {
+            ChunkMap.TrackedEntity trackedEntity = entity.tracker;
+            if (trackedEntity != null) {
+                trackedEntity.broadcast(new ClientboundDamageEventPacket(entity, damageEventPacket.getSource(entity.level())));
+            }
+        } else if (packet instanceof ClientboundEntityEventPacket entityEventPacket) {
+            ChunkMap.TrackedEntity trackedEntity = entity.tracker;
+            if (trackedEntity != null) {
+                trackedEntity.broadcast(new ClientboundEntityEventPacket(entity, entityEventPacket.getEventId()));
+            }
+        } else if (packet instanceof ClientboundSetEquipmentPacket setEquipmentPacket) {
+            for (Pair<EquipmentSlot, ItemStack> pair : setEquipmentPacket.getSlots()) {
+                entity.setItemSlot(pair.getFirst(), pair.getSecond());
+            }
+            if (entity instanceof LivingEntity livingEntity) {
+                livingEntity.detectEquipmentUpdates();
+            }
+        } else {
+            LOGGER.warn("Unhandled packet " + packet);
+        }
+    }
+
+    private static void setFallDistance(Entity entity, double newY) {
+        double oldY = entity.getY();
+
+        if (newY >= oldY) {
+            entity.fallDistance = 0;
+        } else {
+            entity.fallDistance += oldY - newY;
+        }
+    }
+
+    public static void handleEntityWithDependenicesUpdate(Entity entity, Entity[] entities, Packet<?> packet) {
+        if (packet instanceof ClientboundSetPassengersPacket setPassengersPacket) {
+            modifyingPassengers = true;
+            for (Entity riding : entity.getPassengers()) {
+                if (!ArrayUtils.contains(entities, riding)) {
+                    riding.stopRiding();
+                }
+            }
+            for (Entity passenger : entities) {
+                if (!entity.getPassengers().contains(passenger)) {
+                    passenger.startRiding(entity, true);
+                }
+            }
+            modifyingPassengers = false;
+        } else if (packet instanceof ClientboundSetEntityLinkPacket setEntityLinkPacket) {
+            if (entities.length == 0) {
+                ((Mob) entity).setLeashedTo(null, true);
+            } else {
+                ((Mob) entity).setLeashedTo(entities[0], true);
+            }
+        } else if (packet instanceof ClientboundTakeItemEntityPacket takeItemEntityPacket) {
+            takingItem = true;
+            ((LivingEntity) entities[0]).take(entity, takeItemEntityPacket.getAmount());
+            takingItem = false;
+        } else {
+            LOGGER.warn("Unhandled dependencies packet " + packet);
+        }
+    }
+
+    public static void onEntitySpawn(Entity entity) {
+        if (!shouldSyncEntity(entity)) return;
+
+        MultiPaper.runSync(() -> { // Run this after the entity has finished spawning
+            if (entity.isRemoved()) {
+                return;
+            }
+
+            NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder((ServerLevel) entity.level(), entity.chunkPosition().x, entity.chunkPosition().z);
+            if (newChunkHolder != null) {
+                MultiPaper.broadcastPacketToExternalServers(newChunkHolder.externalEntitiesSubscribers, () -> new EntityUpdateNBTPacket(entity));
+                MultiPaper.broadcastPacketToExternalServers(newChunkHolder.externalEntitiesSubscribers, () -> new EntityUpdatePacket(entity, new ClientboundSetEntityDataPacket(entity.getId(), entity.getEntityData().getAll())));
+            } else {
+                LOGGER.warn(entity + " spawned in an unloaded chunk, broadcasting it to all servers just incase anyone has it loaded");
+                MultiPaper.broadcastPacketToExternalServers(new EntityUpdateNBTPacket(entity));
+                MultiPaper.broadcastPacketToExternalServers(new EntityUpdatePacket(entity, new ClientboundSetEntityDataPacket(entity.getId(), entity.getEntityData().getAll())));
+            }
+        });
+    }
+
+    public static boolean shouldSyncEntity(Entity entity) {
+        return entity.shouldBeSaved() || entity instanceof LightningBolt || entity instanceof LeashFenceKnotEntity;
+    }
+
+    public static void onEntityRemove(Entity entity, Entity.RemovalReason reason) {
+        if (!shouldSyncEntity(entity) && MultiPaperEntitiesHandler.getControllingPassenger(entity) == entity && !entity.isPassenger() && !(entity instanceof Player && reason == Entity.RemovalReason.KILLED)) return;
+        if (removingEntity) return;
+        if (entity instanceof ExternalPlayer) return;
+        if (reason == Entity.RemovalReason.UNLOADED_TO_CHUNK) return;
+
+        NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder((ServerLevel) entity.level(), entity.chunkPosition().x, entity.chunkPosition().z);
+        if (newChunkHolder != null) {
+            MultiPaper.broadcastPacketToExternalServers(newChunkHolder.externalEntitiesSubscribers, () -> new EntityRemovePacket(entity, reason == Entity.RemovalReason.UNLOADED_WITH_PLAYER));
+        } else {
+            LOGGER.warn(entity + " removed in an unloaded chunk");
+        }
+    }
+
+    public static void onEntityUpdate(Entity entity, Packet<?> packet, NewChunkHolder newChunkHolder) {
+        if (!entity.shouldBeSaved() && !(entity instanceof ServerPlayer) && (entity.getPassengers().isEmpty() || entity.getIndirectPassengersStream().noneMatch(e -> e instanceof ServerPlayer))) return;
+
+        if (packet instanceof ClientboundSetEquipmentPacket && entity instanceof ServerPlayer) {
+            // This is handled with inventories for players
+            return;
+        } else if (packet instanceof ClientboundSetPassengersPacket setPassengersPacket) {
+            List<Entity> entities = new ArrayList<>();
+            for (int id : setPassengersPacket.getPassengers()) {
+                entities.add(entity.level().getEntity(id));
+            }
+            MultiPaper.broadcastPacketToExternalServers(newChunkHolder.externalEntitiesSubscribers, () -> new EntityUpdateWithDependenciesPacket(entity, entities, packet));
+            return;
+        } else if (packet instanceof ClientboundSetEntityLinkPacket setEntityLinkPacket) {
+            List<Entity> entities = new ArrayList<>();
+            entities.add(entity.level().getEntity(setEntityLinkPacket.getDestId()));
+            MultiPaper.broadcastPacketToExternalServers(newChunkHolder.externalEntitiesSubscribers, () -> new EntityUpdateWithDependenciesPacket(entity, entities, packet));
+            return;
+        } else if (packet instanceof ClientboundTakeItemEntityPacket takeItemEntityPacket) {
+            List<Entity> entities = new ArrayList<>();
+            entities.add(entity.level().getEntity(takeItemEntityPacket.getPlayerId()));
+            MultiPaper.broadcastPacketToExternalServers(newChunkHolder.externalEntitiesSubscribers, () -> new EntityUpdateWithDependenciesPacket(entity, entities, packet));
+            return;
+        }
+
+        if (packet instanceof ClientboundBlockUpdatePacket) {
+            MultiPaperChunkHandler.onBlockUpdate(newChunkHolder, packet);
+            return;
+        }
+
+        if (MultiPaper.isRealPlayer(entity) && !(MultiPaperConfiguration.get().optimizations.reducePlayerPositionUpdatesInUnloadedChunks && packet instanceof ClientboundMoveEntityPacket)) {
+            MultiPaper.broadcastPacketToExternalServers(new EntityUpdatePacket(entity, packet));
+            return;
+        }
+
+        if (newChunkHolder != null) {
+            MultiPaper.broadcastPacketToExternalServers(newChunkHolder.externalEntitiesSubscribers, () -> new EntityUpdatePacket(entity, packet));
+        } else {
+            LOGGER.warn("onEntityUpdate was called for an unloaded chunk " + entity);
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperPlayerHandler.java b/src/main/java/puregero/multipaper/MultiPaperPlayerHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..1b826e5e3194728467fdeb4cf0d87a250caec461
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperPlayerHandler.java
@@ -0,0 +1,21 @@
+package puregero.multipaper;
+
+import net.minecraft.network.protocol.game.ServerboundClientInformationPacket;
+import net.minecraft.network.protocol.game.ServerboundPlayerAbilitiesPacket;
+import net.minecraft.network.protocol.game.ServerboundSetCarriedItemPacket;
+import net.minecraft.server.level.ServerPlayer;
+import puregero.multipaper.externalserverprotocol.PlayerActionPacket;
+
+public class MultiPaperPlayerHandler {
+    public static void handlePlayerAbilities(ServerPlayer player, ServerboundPlayerAbilitiesPacket packet) {
+        if (MultiPaper.isRealPlayer(player)) {
+            MultiPaper.broadcastPacketToExternalServers(player, new PlayerActionPacket(player, packet));
+        }
+    }
+
+    public static void handleClientInformation(ServerPlayer player, ServerboundClientInformationPacket packet) {
+        if (MultiPaper.isRealPlayer(player)) {
+            MultiPaper.broadcastPacketToExternalServers(player, new PlayerActionPacket(player, packet));
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/EntityRemovePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/EntityRemovePacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..4899e5ed6988fcef9d86e5a1f070cfb6ab6c1a10
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/EntityRemovePacket.java
@@ -0,0 +1,100 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.level.entity.Visibility;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperEntitiesHandler;
+
+import java.util.HashMap;
+import java.util.UUID;
+
+public class EntityRemovePacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(EntityRemovePacket.class.getSimpleName());
+
+    public static final HashMap<UUID, Entity.RemovalReason> removedEntities = new HashMap<>();
+
+    private final String world;
+    private final UUID uuid;
+    private final boolean unloadedWithPlayer;
+
+    public EntityRemovePacket(Entity entity, boolean unloadedWithPlayer) {
+        this(((ServerLevel) entity.level()).convertable.getLevelId(), entity.getUUID(), unloadedWithPlayer);
+    }
+
+    public EntityRemovePacket(String world, UUID uuid, boolean unloadedWithPlayer) {
+        this.world = world;
+        this.uuid = uuid;
+        this.unloadedWithPlayer = unloadedWithPlayer;
+    }
+
+    public EntityRemovePacket(FriendlyByteBuf in) {
+        this.world = in.readUtf();
+        this.uuid = in.readUUID();
+        this.unloadedWithPlayer = in.readBoolean();
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+        out.writeUUID(uuid);
+        out.writeBoolean(this.unloadedWithPlayer);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(this::removeEntity);
+    }
+
+    private void removeEntity() {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+
+        Entity entity = level.getEntity(uuid);
+        Visibility visibility = level.getEntityLookup().getEntityStatusByUUID(uuid);
+
+        if (entity != null || visibility != null) {
+            MultiPaperEntitiesHandler.removingEntity = true;
+            Entity.RemovalReason reason = entity instanceof Player ? Entity.RemovalReason.KILLED : Entity.RemovalReason.DISCARDED;
+            if (this.unloadedWithPlayer) reason = Entity.RemovalReason.UNLOADED_WITH_PLAYER;
+
+            if (entity != null) {
+                entity.setRemoved(reason);
+            } else {
+                // Entity is not accessible, force its removal
+                level.getEntityLookup().forceRemove(uuid);
+                setEntityRemoved(uuid, reason);
+            }
+
+            MultiPaperEntitiesHandler.removingEntity = false;
+        } else if (!this.unloadedWithPlayer) {
+            setEntityRemoved(uuid, Entity.RemovalReason.DISCARDED);
+        }
+
+        // Check if the entity was actually removed
+        visibility = level.getEntityLookup().getEntityStatusByUUID(uuid);
+        if (visibility != null) {
+            LOGGER.warn("Tried to remove entity {} but it still exists with visibility {}: {}", uuid, visibility, entity);
+        }
+    }
+
+    public static void setEntityRemoved(UUID uuid, Entity.RemovalReason reason) {
+        setEntityRemoved(uuid, reason, 300);
+    }
+
+    public static void setEntityRemoved(UUID uuid, Entity.RemovalReason reason, int durationInTicks) {
+        if (reason == Entity.RemovalReason.UNLOADED_WITH_PLAYER) return;
+        removedEntities.put(uuid, reason);
+        ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> {
+            removedEntities.remove(uuid, reason);
+        }, durationInTicks, "EntityRemovePacket-removeEntryFromRemovedEntities");
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateNBTPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateNBTPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..dc7c7aa6a67e3a7107b6d8d1d6b2ad461e7d160d
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateNBTPacket.java
@@ -0,0 +1,149 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.level.entity.Visibility;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.IOException;
+import java.util.UUID;
+
+public class EntityUpdateNBTPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(EntityUpdateNBTPacket.class.getSimpleName());
+
+    private final String world;
+    private final UUID uuid;
+    private final byte[] data;
+
+    public EntityUpdateNBTPacket(Entity entity) {
+        this.world = ((ServerLevel) entity.level()).convertable.getLevelId();
+        this.uuid = entity.getUUID();
+
+        CompoundTag tag = new CompoundTag();
+
+        entity.isSyncing = true;
+        entity.save(tag);
+        entity.isSyncing = false;
+
+        if (tag.getAllKeys().isEmpty()) {
+            new Exception("Sending an empty entity " + entity).printStackTrace();
+        }
+
+        try {
+            this.data = MultiPaper.nbtToBytes(tag);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public EntityUpdateNBTPacket(FriendlyByteBuf in) {
+        this.world = in.readUtf();
+        this.uuid = in.readUUID();
+        this.data = in.readByteArray();
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+        out.writeUUID(uuid);
+        out.writeByteArray(data);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            try {
+                World bukkitWorld = Bukkit.getWorld(world);
+
+                if (bukkitWorld instanceof CraftWorld craftWorld) {
+                    ServerLevel level = craftWorld.getHandle();
+                    CompoundTag tag = MultiPaper.nbtFromBytes(data);
+                    loadEntity(level, tag, uuid);
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+    }
+
+    public static Entity loadEntity(ServerLevel level, CompoundTag tag, UUID uuid) {
+        Entity.RemovalReason removalReason = EntityRemovePacket.removedEntities.get(uuid);
+        if (removalReason != null && removalReason.shouldDestroy()) {
+            // We've already removed this entity. This is likely a race condition, so don't recreate the entity.
+            return null;
+        }
+
+
+
+        Entity entity = level.getEntity(uuid);
+        Visibility visibility = level.getEntityLookup().getEntityStatusByUUID(uuid);
+        if (visibility != null && !visibility.isAccessible()) {
+            level.getEntityLookup().forceRemove(uuid); // This entity is in an inaccessible area, so force its removal so that we can replace it
+            entity = level.getEntity(uuid);
+            visibility = level.getEntityLookup().getEntityStatusByUUID(uuid);
+        }
+
+        if (visibility != null && !visibility.isAccessible()) {
+            LOGGER.warn("Tried to load entity {} but its in an inaccessible area", uuid);
+            return null;
+        }
+
+        if (entity == null && visibility == null) {
+            entity = EntityType.loadEntityRecursive(tag, level, entity2 -> {
+                if (level.areEntitiesLoaded(entity2.chunkPosition().longKey)) {
+                    level.getEntityLookup().addNewEntity(entity2);
+                    if (entity2 instanceof Mob mob) mob.restoreLeashFromSave();
+                    return entity2;
+                } else {
+                    EntityRemovePacket.setEntityRemoved(uuid, Entity.RemovalReason.UNLOADED_TO_CHUNK, 20);
+                    /*
+                     * disable this not needed warn,
+                     * since chunk system rewrite, chunk system is now true async which can unload/load without main thread knowing?
+                     * since spawning is executed on the main thread (this),
+                     * not sure if this is right explanation about chunk system rewrite.
+                     * - Ham1255
+                     */
+                    // LOGGER.warn("Tried to create an entity from nbt, but the entities for that chunk aren't loaded: " + entity2);
+                    return null;
+                }
+            });
+        } else if (entity instanceof ServerPlayer player) {
+            new Exception("Tried to update the nbt of player " + player.getScoreboardName() + " to " + tag).printStackTrace();
+        } else {
+            entity.load(tag);
+            if (entity.tracker != null) {
+                entity.tracker.serverEntity.teleportDelay = 10000;
+            }
+        }
+
+        if (tag.contains("Passengers", 9)) {
+            ListTag nbttaglist = tag.getList("Passengers", 10);
+
+            for (int i = 0; i < nbttaglist.size(); ++i) {
+                CompoundTag passengerTag = nbttaglist.getCompound(i);
+                Entity passenger = loadEntity(level, passengerTag, passengerTag.getUUID("UUID"));
+
+                if (passenger != null) {
+                    passenger.startRiding(entity, true);
+                }
+            }
+        }
+
+        if (entity instanceof Mob mob) mob.restoreLeashFromSave();
+
+        return entity;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdatePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdatePacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..c3799fb4bd23a754ebf28d266dd7b0b17d93e337
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdatePacket.java
@@ -0,0 +1,119 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.entity.Visibility;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperEntitiesHandler;
+
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class EntityUpdatePacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(EntityUpdatePacket.class.getSimpleName());
+
+    // If anyone has a better idea for locking only certain threads rather than creating a set of the thread ids that need locking, plz contribute
+    public static Set<Long> threadsWritingUpdatePackets = ConcurrentHashMap.newKeySet();
+
+    private final UUID world;
+    private final UUID uuid;
+    private final Packet<?> packet;
+
+    private final long chunkPos;
+
+    public EntityUpdatePacket(Entity entity, Packet<?> packet) {
+        this.world = ((ServerLevel) entity.level()).uuid;
+        this.uuid = entity.getUUID();
+        this.packet = packet;
+        this.chunkPos = entity.chunkPosition().longKey;
+    }
+
+    public EntityUpdatePacket(FriendlyByteBuf in) {
+        world = in.readUUID();
+        uuid = in.readUUID();
+
+        ByteBuf buf = Unpooled.wrappedBuffer(in.readByteArray());
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        int packetId = friendlyByteBuf.readVarInt();
+        packet = ConnectionProtocol.PLAY.createPacket(PacketFlow.CLIENTBOUND, packetId, friendlyByteBuf);
+        this.chunkPos = in.readLong();
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUUID(world);
+        out.writeUUID(uuid);
+
+        ConnectionProtocol protocol = ConnectionProtocol.getProtocolForPacket(packet);
+        Integer id = protocol.getPacketId(PacketFlow.CLIENTBOUND, packet);
+        ByteBuf buf = Unpooled.buffer();
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        friendlyByteBuf.writeVarInt(id);
+        threadsWritingUpdatePackets.add(Thread.currentThread().getId());
+        packet.write(friendlyByteBuf);
+        threadsWritingUpdatePackets.remove(Thread.currentThread().getId());
+        out.writeByteArray(buf.array());
+        out.writeLong(this.chunkPos);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> handleLater(connection, 0));
+    }
+
+    private void handleLater(ExternalServerConnection connection, int depth) {
+        World bukkitWorld = Bukkit.getWorld(world);
+
+        if (bukkitWorld instanceof CraftWorld craftWorld) {
+            ServerLevel level = craftWorld.getHandle();
+            Entity entity = level.getEntity(uuid);
+            Visibility visibility = level.getEntityLookup().getEntityStatusByUUID(uuid);
+            if (visibility != null && !visibility.isAccessible()) {
+                return;
+            }
+            if (entity == null && visibility == null) {
+                if (EntityRemovePacket.removedEntities.containsKey(uuid)) {
+                    return;
+                }
+
+                // If we can't find the entity, try again later,
+                // the spawn entity packet is probably coming later
+
+                // first we check if we really need to request the entity by checking if entity's chunk is loaded
+                if (!level.areEntitiesLoaded(this.chunkPos)) {
+                    return;
+                }
+
+                if (depth > 5) {
+                    if (depth >= 20) {
+                        LOGGER.warn("Could not find entity " + uuid + " for " + packet.getClass().getSimpleName() + ", requesting it");
+                    }
+                    RequestEntityPacket.requestEntity(connection, world, uuid);
+                    return;
+                }
+
+                ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> {
+                    handleLater(connection, depth + 1);
+                }, 1, "EntityUpdatePacket-handleLaters");
+                return;
+            }
+
+            MultiPaperEntitiesHandler.handleEntityUpdate(connection, entity, packet);
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateWithDependenciesPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateWithDependenciesPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..9a5c01a9fb8ff40f1d3ee870dea491d70794f77b
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateWithDependenciesPacket.java
@@ -0,0 +1,188 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.entity.Visibility;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import puregero.multipaper.ExternalServer;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperEntitiesHandler;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Objects;
+import java.util.UUID;
+import java.util.function.Consumer;
+
+public class EntityUpdateWithDependenciesPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(EntityUpdateWithDependenciesPacket.class.getSimpleName());
+
+    private final UUID world;
+    private final UUID uuid;
+    private final UUID[] uuids;
+    private final Packet<?> packet;
+    private final long chunkPos;
+
+    public EntityUpdateWithDependenciesPacket(Entity entity, Collection<Entity> dependents, Packet<?> packet) {
+        this.world = ((ServerLevel) entity.level()).uuid;
+        this.uuid = entity.getUUID();
+        this.uuids = dependents.stream().filter(Objects::nonNull).map(Entity::getUUID).toArray(UUID[]::new);
+        this.packet = packet;
+        this.chunkPos = entity.chunkPosition().longKey;
+    }
+
+    public EntityUpdateWithDependenciesPacket(FriendlyByteBuf in) {
+        world = in.readUUID();
+        uuid = in.readUUID();
+
+        uuids = new UUID[in.readVarInt()];
+
+        for (int i = 0; i < uuids.length; i++) {
+            uuids[i] = in.readUUID();
+        }
+
+        ByteBuf buf = Unpooled.wrappedBuffer(in.readByteArray());
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        int packetId = friendlyByteBuf.readVarInt();
+        packet = ConnectionProtocol.PLAY.createPacket(PacketFlow.CLIENTBOUND, packetId, friendlyByteBuf);
+        this.chunkPos = in.readLong();
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUUID(world);
+        out.writeUUID(uuid);
+
+        out.writeVarInt(uuids.length);
+        for (UUID uuid : uuids) {
+            out.writeUUID(uuid);
+        }
+
+        ConnectionProtocol protocol = ConnectionProtocol.getProtocolForPacket(packet);
+        Integer id = protocol.getPacketId(PacketFlow.CLIENTBOUND, packet);
+        ByteBuf buf = Unpooled.buffer();
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        friendlyByteBuf.writeVarInt(id);
+        packet.write(friendlyByteBuf);
+        out.writeByteArray(buf.array());
+        out.writeLong(this.chunkPos);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> handleLater(connection, 0));
+    }
+
+    private void handleLater(ExternalServerConnection connection, int depth) {
+        World bukkitWorld = Bukkit.getWorld(world);
+
+        if (bukkitWorld instanceof CraftWorld craftWorld) {
+            ServerLevel level = craftWorld.getHandle();
+            Entity entity = level.getEntity(uuid);
+            Visibility visibility = level.getEntityLookup().getEntityStatusByUUID(uuid);
+            if (visibility != null && !visibility.isAccessible()) {
+                return;
+            }
+            if (entity == null && visibility == null) {
+                if (EntityRemovePacket.removedEntities.containsKey(uuid)) {
+                    return;
+                }
+
+                // If we can't find the entity, try again later,
+                // the spawn entity packet is probably coming later
+
+                // first we check if we really need to request the entity by checking if entity's chunk is loaded
+                if (!level.areEntitiesLoaded(this.chunkPos)) {
+                    return;
+                }
+
+                if (depth > 5) {
+                    LOGGER.warn("Could not find entity " + uuid + " for " + packet.getClass().getSimpleName() + ", requesting it");
+                    RequestEntityPacket.requestEntity(connection, world, uuid);
+                    return;
+                }
+
+                ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> {
+                    handleLater(connection, depth + 1);
+                }, 1, "EntityUpdateWithDependenciesPacket-handleLater");
+                return;
+            }
+
+            Entity[] entities = new Entity[uuids.length];
+
+            for (int i = 0; i < uuids.length; i++) {
+                entities[i] = level.getEntity(uuids[i]);
+
+                if (entities[i] == null) {
+                    if (EntityRemovePacket.removedEntities.containsKey(uuids[i])) {
+                        return;
+                    }
+
+                    if (depth > 5) {
+                        LOGGER.warn("Could not find dependent entity " + uuids[i] + " for " + packet.getClass().getSimpleName() + ", requesting it");
+                        RequestEntityPacket.requestEntity(connection, world, uuids[i]);
+                        return;
+                    }
+
+                    ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> {
+                        handleLater(connection, depth + 1);
+                    }, 1, "EntityUpdateWithDependenciesPacket-handleLater");
+                    return;
+                }
+            }
+
+            MultiPaperEntitiesHandler.handleEntityWithDependenicesUpdate(entity, entities, packet);
+        }
+    }
+
+    public static void sendVehicleAndPassengersPacketsRecursivelyToServers(Entity entity, Collection<ExternalServer> servers) {
+        if (!servers.isEmpty()) {
+            compileVehicleAndPassengersPacketsRecursively(entity).forEach(packet -> MultiPaper.broadcastPacketToExternalServers(servers, packet));
+        }
+    }
+
+    /**
+     * Get a list of packets that contain the entity, and it's vehicles and passengers (recursively)'s NBT data, along with
+     * any other packets that are required to link the passengers to their vehicles.
+     * Order of packets must be maintained.
+     */
+    public static List<ExternalServerPacket> compileVehicleAndPassengersPacketsRecursively(Entity entity) {
+        List<ExternalServerPacket> packets = new ArrayList<>();
+
+        compilePacketsForEntityAndPassengers(entity.getRootVehicle(), packets);
+
+        return packets;
+    }
+
+    private static void compilePacketsForEntityAndPassengers(Entity entity, List<ExternalServerPacket> packets) {
+        if (!(entity instanceof ServerPlayer) && (entity.getVehicle() == null || entity.getVehicle() instanceof ServerPlayer)) {
+            // This entity is the vehicle and will save the nbt for itself and all its passengers
+            // Note that Players don't get saved, so any entity riding a player will also need to be saved
+            packets.add(new EntityUpdateNBTPacket(entity));
+        }
+
+        for (Entity passenger : entity.getPassengers()) {
+            compilePacketsForEntityAndPassengers(passenger, packets);
+        }
+
+        // Link the passengers to their vehicle (especially important if a vehicle or passenger is a player)
+        // (And also unlink old passengers from the vehicle)
+        packets.add(new EntityUpdateWithDependenciesPacket(entity, entity.getPassengers(), new ClientboundSetPassengersPacket(entity)));
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
index c41679ee4e55cc5765d30acb4289be79291a9624..8ce98e04ed1400146b69242a3a28c9689fd47e68 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -35,6 +35,13 @@ public class ExternalServerPacketSerializer {
         addPacket(PlayerActionPacket.class, PlayerActionPacket::new);
         addPacket(PlayerInventoryUpdatePacket.class, PlayerInventoryUpdatePacket::new);
         addPacket(TimeUpdatePacket.class, TimeUpdatePacket::new);
+        addPacket(RequestEntitiesPacket.class, RequestEntitiesPacket::new);
+        addPacket(SendEntitiesPacket.class, SendEntitiesPacket::new);
+        addPacket(EntityUpdateNBTPacket.class, EntityUpdateNBTPacket::new);
+        addPacket(EntityUpdatePacket.class, EntityUpdatePacket::new);
+        addPacket(EntityUpdateWithDependenciesPacket.class, EntityUpdateWithDependenciesPacket::new);
+        addPacket(RequestEntityPacket.class, RequestEntityPacket::new);
+        addPacket(EntityRemovePacket.class, EntityRemovePacket::new);
     }
 
     private static void addPacket(Class<? extends ExternalServerPacket> clazz, Function<FriendlyByteBuf, ExternalServerPacket> deserializer) {
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/PlayerActionPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerActionPacket.java
index 7564da61c6bcdbb51c3be4d95949f1c4138cb550..4faa8760c41cedb1d9a98608be4522b4490324e8 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/PlayerActionPacket.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerActionPacket.java
@@ -12,6 +12,8 @@ import net.minecraft.server.level.ServerPlayer;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
 import java.util.UUID;
 
 public class PlayerActionPacket extends ExternalServerPacket {
@@ -46,11 +48,15 @@ public class PlayerActionPacket extends ExternalServerPacket {
 
     @Override
     public void handle(ExternalServerConnection connection) {
-        ServerPlayer player = MinecraftServer.getServer().getPlayerList().getPlayer(uuid);
-        if (player == null) {
-            LOGGER.warn("Tried to run an action on a non-existent player with uuid " + uuid);
-            return;
+        MultiPaper.runSync(() -> {
+            ServerPlayer player = MinecraftServer.getServer().getPlayerList().getPlayer(uuid);
+
+            if (player == null) {
+                LOGGER.warn("Tried to run an action on a non-existent player with uuid " + uuid);
+                return;
+
         }
-        player.server.execute(() -> action.handle(player.connection));
+            action.handle(player.connection);
+        });
     }
 }
\ No newline at end of file
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/PlayerCreatePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerCreatePacket.java
index 1336577a2ee2c677365db61bbf44898a25f127fb..2b03890bb03ebe27e0191128aad728a38219caeb 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/PlayerCreatePacket.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerCreatePacket.java
@@ -1,11 +1,15 @@
 package puregero.multipaper.externalserverprotocol;
 
 import com.mojang.authlib.GameProfile;
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.game.ServerboundSetCarriedItemPacket;
+import net.minecraft.network.protocol.game.ClientboundSetEntityDataPacket;
+import net.minecraft.network.protocol.game.ServerboundClientInformationPacket;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.HumanoidArm;
 import net.minecraft.world.level.GameType;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -15,6 +19,8 @@ import puregero.multipaper.*;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.List;
 
 public class PlayerCreatePacket extends ExternalServerPacket {
 
@@ -120,5 +126,28 @@ public class PlayerCreatePacket extends ExternalServerPacket {
 
         send(new PlayerCreatePacket(player, player.saveWithoutId(new CompoundTag())), connections);
         send(new PlayerActionPacket(player, new ServerboundSetCarriedItemPacket(player.getInventory().selected)), connections);
+
+        send(new EntityUpdatePacket(player, new ClientboundSetEntityDataPacket(player.getId(), player.getEntityData().getAll())), connections);
+
+        if (player.clientViewDistance != null) {
+            send(new PlayerActionPacket(player, new ServerboundClientInformationPacket(
+                    player.locale,
+                    player.clientViewDistance,
+                    player.getChatVisibility(),
+                    player.canChatInColor(),
+                    player.getEntityData().get(ServerPlayer.DATA_PLAYER_MODE_CUSTOMISATION),
+                    player.getEntityData().get(ServerPlayer.DATA_PLAYER_MAIN_HAND) == 0 ? HumanoidArm.LEFT : HumanoidArm.RIGHT,
+                    player.isTextFilteringEnabled(),
+                    player.allowsListing()
+            )), connections);
+        }
+
+        if (player.isPassenger() || player.isVehicle()) {
+            NewChunkHolder newChunkHolder = MultiPaper.getChunkHolder(player.getRootVehicle());
+            if (newChunkHolder != null) {
+                List<ExternalServer> subscribedServers = Arrays.stream(connections).filter(e -> newChunkHolder.externalEntitiesSubscribers.contains(e.externalServer)).map(connection -> connection.externalServer).toList();
+                EntityUpdateWithDependenciesPacket.sendVehicleAndPassengersPacketsRecursivelyToServers(player.getRootVehicle(), subscribedServers);
+            }
+        }
     }
 }
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/RequestEntitiesPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/RequestEntitiesPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..26df6c6d6052f71da435d4ef973d1bb15b103bc3
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/RequestEntitiesPacket.java
@@ -0,0 +1,79 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.game.ClientboundTeleportEntityPacket;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.config.MultiPaperConfiguration;
+
+import java.util.ConcurrentModificationException;
+import java.util.concurrent.CompletableFuture;
+
+public class RequestEntitiesPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(RequestEntitiesPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+
+    public RequestEntitiesPacket(String world, int cx, int cz) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+    }
+
+    public RequestEntitiesPacket(FriendlyByteBuf in) {
+        world = in.readUtf();
+        cx = in.readInt();
+        cz = in.readInt();
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        sendChunkLater(connection, world, cx, cz, 0);
+    }
+
+    private void sendChunkLater(ExternalServerConnection connection, String world, int cx, int cz, int depth) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        NewChunkHolder chunkHolder = level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(ChunkPos.asLong(cx, cz));
+        if (chunkHolder == null || chunkHolder.getEntityChunk() == null) {
+            if (depth >= 20 || Bukkit.isStopping()) {
+                LOGGER.warn(connection.externalServer.getName() + " is requesting entities " + world + "," + cx + "," + cz + " but we timed out waiting for them to load.");
+                connection.send(new SendEntitiesPacket(world, cx, cz, null));
+                return;
+            }
+            ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> {
+                sendChunkLater(connection, world, cx, cz, depth + 1);
+            }, 1, "ExternalServerConnection-sendEntitiesLater");
+        } else {
+            try {
+                connection.send(new SendEntitiesPacket(level.getWorld().getName(), cx, cz, SendEntitiesPacket.getEntities(level, new ChunkPos(cx, cz), player -> {
+                    if (MultiPaperConfiguration.get().optimizations.reducePlayerPositionUpdatesInUnloadedChunks) {
+                        // This player is now in a loaded chunk, ensure its position is up to date
+                        connection.send(new EntityUpdatePacket(player, new ClientboundTeleportEntityPacket(player)));
+                    }
+                })));
+            } catch (ConcurrentModificationException e) {
+                LOGGER.warn("Got ConcurrentModificationException while sending entities, sending it in main thread instead");
+                MultiPaper.runSync(() -> sendChunkLater(connection, world, cx, cz, depth));
+            }
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/RequestEntityPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/RequestEntityPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..bf9f0bf5e24fe8c70fd7895df289421a38fa87b9
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/RequestEntityPacket.java
@@ -0,0 +1,120 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.papermc.paper.chunk.system.scheduling.NewChunkHolder;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.entity.Visibility;
+import org.apache.commons.lang3.tuple.Pair;
+import org.apache.commons.lang3.tuple.Triple;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+
+public class RequestEntityPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(RequestEntityPacket.class.getSimpleName());
+
+    private static final Map<Pair<UUID, ExternalServerConnection>, Integer> playerRequestCounts = new HashMap<>();
+    private static final Set<Triple<String, UUID, UUID>> requestedEntitiesThisTick = new HashSet<>();
+
+    private final UUID world;
+    private final UUID uuid;
+
+    public static void tick() {
+        requestedEntitiesThisTick.clear();
+    }
+
+    public static void requestEntity(ExternalServerConnection connection, UUID world, UUID entity) {
+        if (!hasAlreadyRequestedThisTick(connection, world, entity)) {
+            connection.send(new RequestEntityPacket(world, entity));
+        }
+    }
+
+    private static boolean hasAlreadyRequestedThisTick(ExternalServerConnection connection, UUID world, UUID entity) {
+        if (!Bukkit.isPrimaryThread()) {
+            LOGGER.warn(new Exception("RequestEntityPacket.requestEntity called off main thread, sending packet async without checks"));
+            return false; // We can't check this async, so just send the packet anyway
+        } else {
+            return !requestedEntitiesThisTick.add(Triple.of(connection.externalServer.getName(), world, entity));
+        }
+    }
+
+    private RequestEntityPacket(UUID world, UUID uuid) {
+        this.world = world;
+        this.uuid = uuid;
+    }
+
+    public RequestEntityPacket(FriendlyByteBuf in) {
+        this.world = in.readUUID();
+        this.uuid = in.readUUID();
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUUID(world);
+        out.writeUUID(uuid);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            CraftWorld craftWorld = ((CraftWorld) Bukkit.getWorld(world));
+            if (craftWorld == null) return;
+            ServerLevel level = craftWorld.getHandle();
+            Entity entity = level.getEntity(uuid);
+            Visibility visibility = level.getEntityLookup().getEntityStatusByUUID(uuid);
+            if (entity != null && visibility != null && visibility.isAccessible()) {
+                if (entity instanceof ServerPlayer serverPlayer) {
+                    triedToRequestPlayer(connection, serverPlayer);
+                    return;
+                }
+
+                // Send the vehicle the entity is in
+                entity = entity.getRootVehicle();
+
+                // Check that the server is subscribed to the entity's chunk
+                Optional<NewChunkHolder> chunkHolder = Optional.ofNullable(level.chunkSource.chunkMap.getVisibleChunkIfPresent(entity.chunkPosition().longKey)).map(holder -> holder.newChunkHolder);
+
+                if (chunkHolder.filter(holder -> holder.externalEntitiesSubscribers.contains(connection.externalServer)).isEmpty()) {
+                    LOGGER.warn(connection.externalServer.getName() + " requested entity " + uuid + ", but that entity is not in a chunk that server is subscribed to (" + craftWorld.getName() + "," + entity.chunkPosition().x + "," + entity.chunkPosition().z + ")");
+                    return;
+                }
+
+                EntityUpdateWithDependenciesPacket.sendVehicleAndPassengersPacketsRecursivelyToServers(entity, List.of(connection.externalServer));
+            } else {
+                LOGGER.warn(connection.externalServer.getName() + " requested entity " + uuid + ", but that entity doesn't exist");
+            }
+        });
+    }
+
+    private void triedToRequestPlayer(ExternalServerConnection connection, ServerPlayer serverPlayer) {
+        if (!MinecraftServer.getServer().getPlayerList().players.contains(serverPlayer)) return;
+        Pair<UUID, ExternalServerConnection> key = Pair.of(serverPlayer.getUUID(), connection);
+        int count = playerRequestCounts.getOrDefault(key, 0);
+        playerRequestCounts.put(key, count + 1);
+        if (count > 10) {
+            LOGGER.error(connection.externalServer.getName() + " tried to request player " + serverPlayer.getScoreboardName() + " more than 10 times! This means they didn't sync correctly. Kicking them.");
+            serverPlayer.getBukkitEntity().kickPlayer("Your player failed to sync. Please reconnect.");
+            playerRequestCounts.remove(key);
+        } else {
+            LOGGER.warn(connection.externalServer.getName() + " tried to request entity " + uuid + ", which is the player " + serverPlayer.getScoreboardName() + "! This means that server is missing that player.");
+            CompletableFuture.runAsync(() -> playerRequestCounts.remove(key), CompletableFuture.delayedExecutor(10, TimeUnit.SECONDS));
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendEntitiesPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendEntitiesPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..81a6e4083284600aadc9372f81e40b6bcd5b670e
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendEntitiesPacket.java
@@ -0,0 +1,155 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.papermc.paper.world.ChunkEntitySlices;
+import net.minecraft.SharedConstants;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.IntArrayTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.LevelChunk;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ChunkKey;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperEntitiesHandler;
+
+import javax.annotation.Nullable;
+import java.io.ByteArrayInputStream;
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.util.function.Consumer;
+import java.util.zip.InflaterInputStream;
+
+public class SendEntitiesPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendEntitiesPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+    private final byte[] data;
+
+    public SendEntitiesPacket(LevelChunk chunk) {
+        this(chunk.level, chunk.getPos(), null);
+    }
+
+    public SendEntitiesPacket(LevelChunk chunk, ChunkEntitySlices chunkEntitySlices) {
+        this(chunk.level, chunk.getPos(), chunkEntitySlices);
+    }
+
+    public SendEntitiesPacket(ServerLevel level, ChunkPos pos, ChunkEntitySlices chunkEntitySlices) {
+        this(level.getWorld().getName(), pos.x, pos.z, getEntities(level, pos, null, chunkEntitySlices));
+    }
+
+    public static CompoundTag getEntities(ServerLevel level, ChunkPos pos, @Nullable Consumer<ServerPlayer> foreachPlayer) {
+        return getEntities(level, pos, foreachPlayer, null);
+    }
+
+    public static CompoundTag getEntities(ServerLevel level, ChunkPos pos, @Nullable Consumer<ServerPlayer> foreachPlayer, @Nullable ChunkEntitySlices chunkEntities) {
+        if (chunkEntities == null) {
+            chunkEntities = level.getEntityLookup().getChunk(pos.x, pos.z);
+            if (chunkEntities == null) {
+                new Exception("Entities are not loaded in " + level.convertable.getLevelId() + pos + ", sending null entities").printStackTrace();
+                return null;
+            }
+        }
+
+        CompoundTag entitiesRoot = new CompoundTag();
+        ListTag entities = new ListTag();
+        for (Entity entity : chunkEntities.entities) {
+            if (MultiPaperEntitiesHandler.shouldSyncEntity(entity)) {
+                CompoundTag tag = new CompoundTag();
+                entity.isSyncing = true;
+                entity.save(tag);
+                entity.isSyncing = false;
+                entities.add(tag);
+            } else if (foreachPlayer != null && entity instanceof ServerPlayer player && MultiPaper.isRealPlayer(player)) {
+                foreachPlayer.accept(player);
+            }
+        }
+        entitiesRoot.putInt("DataVersion", SharedConstants.getCurrentVersion().getDataVersion().getVersion());
+        entitiesRoot.put("Entities", entities);
+        entitiesRoot.put("Position", new IntArrayTag(new int[]{pos.x, pos.z}));
+        return entitiesRoot;
+    }
+
+    public SendEntitiesPacket(String world, int cx, int cz, CompoundTag tag) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+
+        try {
+            if (tag == null) {
+                data = new byte[0];
+            } else {
+                data = MultiPaper.nbtToBytes(tag);
+            }
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public SendEntitiesPacket(FriendlyByteBuf in) {
+        world = in.readUtf();
+        cx = in.readInt();
+        cz = in.readInt();
+        data = in.readByteArray();
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeByteArray(data);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        try {
+            Consumer<DataInputStream> callback = connection.entitiesCallbacks.remove(new ChunkKey(world, cx, cz));
+            if (callback != null) {
+                if (data.length == 0) {
+                    LOGGER.warn(connection.externalServer.getName() + " sent us an empty entities for " + world + "," + cx + "," + cz + ", force loading it from disk");
+                    MultiPaper.forceReadChunk(world, "entities", cx, cz).thenAccept(data2 -> callback.accept(data2.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data2)))));
+                } else {
+                    callback.accept(new DataInputStream(new ByteArrayInputStream(data)));
+                }
+            } else {
+                if (data.length == 0) {
+                    return;
+                }
+
+                // Replace the existing entities with these new entities
+                ChunkPos pos = new ChunkPos(cx, cz);
+                ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+                // Check that we have these entities loaded in the first place
+                if (level.areEntitiesLoaded(pos.longKey)) {
+                    CompoundTag tag = MultiPaper.nbtFromBytes(data);
+                    ListTag entities = tag == null ? new ListTag() : tag.getList("Entities", Tag.TAG_COMPOUND);
+                    MultiPaper.runSync(() -> {
+                        for (Tag entityTag : entities) {
+                            CompoundTag entityTagCompound = (CompoundTag) entityTag;
+                            EntityUpdateNBTPacket.loadEntity(level, entityTagCompound, entityTagCompound.getUUID("UUID"));
+                        }
+                    });
+                }
+                // commented out
+                // set EntityUpdateNBTPacket line 109 for explanation
+                // else {
+                //  LOGGER.warn("Unsolicited entities for " + world + "," + cx + "," + cz);
+                // }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
index c9ad59beb1115af9b058b3a03e41705f74df2cba..ede67414c73e03f90360e7d7e3a20ce2c63fd318 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
@@ -7,6 +7,7 @@ import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketFlow;
 import net.minecraft.network.protocol.game.*;
+import net.minecraft.server.level.ServerLevel;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import puregero.multipaper.ExternalServerConnection;
@@ -23,6 +24,10 @@ public class SendUpdatePacket extends ExternalServerPacket {
     private final UUID world;
     private final Packet<?> packet;
 
+    public SendUpdatePacket(ServerLevel level, Packet<?> packet) {
+        this(level.uuid, packet);
+    }
+
     public SendUpdatePacket(UUID world, Packet<?> packet) {
         this.world = world;
         this.packet = packet;
